!function(e,t){for(var s in t)e[s]=t[s]}(exports,function(e){var t={};function s(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,s),r.l=!0,r.exports}return s.m=e,s.c=t,s.d=function(e,t,i){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,t){if(1&t&&(e=s(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(s.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)s.d(i,r,function(t){return e[t]}.bind(null,r));return i},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="",s(s.s=2)}([function(e,t,s){const{Log:i,assert:r,warn:o}=s(1);e.exports=class{constructor({name:e,global:t},{data:s={},model:i={},actions:r={},filters:o={},indexes:n=[],groups:a=[],routes:l={},watch:h={},persist:c=[],onLoad:d}){this._name=e,this._actionRefrence={collect:this.collect.bind(this),undo:this.undo.bind(this),move:this.move.bind(this),update:this.update.bind(this),put:this.put.bind(this),delete:this.delete.bind(this),findById:this.findById.bind(this),getGroup:this.getGroup.bind(this),newGroup:this.newGroup.bind(this),forceUpdate:this.forceUpdate.bind(this),throttle:this.throttle.bind(this),remove:this.remove.bind(this),removeGroup:this.remove.bind(this),set:this.set.bind(this)};this._public=this.initProxy({groups:{},data:{},actions:{},filters:{},routes:{},indexes:{}}),this._global=t,this._regenQueue=this._global.regenQueue,this._onLoad=d,this._model=i,this._filters=o,this._data={},this._indexes={},this.watchers={},this._filtersRelatedToData={},this._filtersRelatedToGroup={},this._relations={},this._subscribedToData={},this._persist=[],this._throttles=[],this._mutableData=[],this._indexesToRegen=[],this._filtersToForceRegen=[],this._collectionSize=0,this._primaryKey=null,this._executing=!1,this._collecting=!1,this._performingAction=!1,this._allowInternalChange=!1,this._global.internalDataRef[this._name]=this._data,this._storage={},this._storage.get=(e=>JSON.parse(this._global.storage.get(e))),this._storage.set=((e,t)=>this._global.storage.set(e,JSON.stringify(t))),this.initModel(i),this.initData(s),this.initGroups(n.concat(a)),this.initRoutes(l),this.initFilters(o),this.initActions(r),this.watchers=h,this.prepareNamespace(),this.initPersist(c)}initData(e){Object.keys(e).forEach(t=>{this._mutableData.push(t),this.initDeepReactivity(e,t)}),this._public.data=this.initProxy(e)}initGroups(e){this._public.groups=this.initProxy({});for(let t of e){if(this._public.groups[t]||this._indexes[t])return r(`Duplicate declaration for index ${t}`);this._indexes[t]=new Array,this._public.groups[t]=new Array}}initFilters(e){let t=Object.keys(e);for(let e of t)this._public.filters[e]=[],this._global.allFilters.push(e)}initRoutes(e){let t=Object.keys(e);for(let s of t)this._public.routes[s]=(t=>e[s](this._global.request,t))}initActions(e){for(let t of Object.keys(e))this._public.actions[t]=(s=>{if(this._throttles.includes(t))return Promise.reject();this._performingAction=t;const i=Object.assign({data:this._public.data,filters:this._public.filters,groups:this._public.groups,actions:this._public.actions,routes:this._public.routes},this._global.dataRef,this._actionRefrence);let r=e[t](i,s);return this._performingAction=!1,r})}initPersist(e=[]){for(let t of e){this._persist.push(t);let e=`_${this._name}_${t}`;if(!this._public.hasOwnProperty(t))return r(`Unable to persist property "${t}" as it does not exist.`);let s=this.searchNamespaceForProperty(t),i=this._storage.get(e);i?s?(this._allowInternalChange=!0,this._public[s][t]=i,this._allowInternalChange=!1,this._public.hasOwnProperty(t)&&(this._allowInternalChange=!0,this._public[t]=i,this._allowInternalChange=!1),this.initDeepReactivity(this._public,t)):r("Unable to persist. Could not determin property type."):s&&this._storage.set(e,this._public[s][t])}}initProxy(e={},t=!1,s=!1){let i;i=t?Object.create({rootProperty:t}):Object.create({rootProperty:t,...this._actionRefrence});for(let t of Object.keys(e))i[t]=e[t];return s?new Proxy(i,{set:(e,t,s)=>{if(Object.getPrototypeOf(e).rootProperty){let i=Object.getPrototypeOf(e).rootProperty;return this._mutableData.includes(i)&&(e[t]=s,this.updateSubscribers(i,this._public[i])),!0}return e[t]=s,!0},get:(e,t,s)=>e[t]}):new Proxy(i,{set:(e,t,s)=>!this._global.initComplete||this._allowInternalChange?(e[t]=s,this._allowInternalChange=!1,!0):this._mutableData.includes(t)?(e[t]=s,this.initDeepReactivity(e,t),this.updateSubscribers(t,s),this.findAndUpdateDependents(t),!0):(Object.keys(this._public).includes(t)?r(`Cannot set data property "${t}" in collection "${this._name}". Filters and groups are not mutable.`):r(`Cannot set data property "${t}" in collection "${this._name}" as "${t}" does not exist.`),!0),get:(e,t,s)=>Object.getPrototypeOf(e).rootProperty?e[t]:(this._global.record&&!["filters","groups","indexes","data","actions"].includes(t)&&0===this._global.dependenciesFound.filter(e=>e.property===t&&e.collection===this._name).length&&this._global.dependenciesFound.push({property:t,collection:this._name}),e[t])})}isWatchableObject(e){return!(null==e||"object"!=typeof e||e instanceof HTMLElement||Array.isArray(e))}initDeepReactivity(e,t){let s,i=[];if(this.isWatchableObject(e[t])){s=Object.getPrototypeOf(e).rootProperty?Object.getPrototypeOf(e).rootProperty:t,this._allowInternalChange=!0,e[t]=this.initProxy(e[t],s,!0);for(let s of Object.keys(e[t]))this.isWatchableObject(e[t][s])&&i.push({target:e[t],key:s});const r=()=>{let e=i;i=[];for(let t of e){let e=t.key,r=t.target;r[e]=this.initProxy(r[e],s,!0);for(let t of Object.keys(r[e]))this.isWatchableObject(r[e][t])&&i.push({target:r[e],key:t})}i.length>0?r():this._allowInternalChange=!1};r()}}initModel(e){Object.keys(e).forEach(t=>{Object.keys(e[t]).forEach(s=>{"primaryKey"===s?this._primaryKey=t:"parent"===s&&this.createDataRelation(t,e[t].parent,e[t].assignTo)})})}createDataRelation(e,t,s){if(!this._global.collectionNamespace.includes(t))return r(`"${collection}" is not a valid collection.`);this._relations[e]={},this._relations[e].fromCollectionName=t,s&&(this._relations[e].assignTo=s)}searchNamespaceForProperty(e){let t=["filters","data","groups"];for(let s of t)if(Object.keys(this._public[s]).includes(e))return s;return!1}validateNamespace(e,t){return Object.keys(e).forEach(s=>{if(e.hasOwnProperty(t))return o(`Duplicate property "${t}" on collection "${this._name}"`),!1}),!0}prepareNamespace(){Object.keys(this._public).forEach(e=>{["data","actions","groups","filters"].includes(e)&&Object.keys(this._public[e]).forEach(t=>{this.validateNamespace(this._public,t)&&(this._public[t]=this._public[e][t])})})}checkNamespace(e){return!!this._public.data.hasOwnProperty(e)||(r(`Namespace error "${e}" is already taken for collection "${this._name}".`),!1)}persistData(e,t){if(this._persist.includes(e)){let s=`_${this._name}_${e}`;i(`Persisting data with key ${s}`),this._storage.set(s,t)}}findPrimaryKey(e){let t=["id","_id"];for(let s of t)e.hasOwnProperty(s)&&(this._primaryKey=s);this._primaryKey||this.dataRejectionHandler(e,"No primary key supplied.")}createRelationForIndex(e){for(let t of Object.keys(this._relations))this._relations[t][e]=[]}analyseFilters(){if(!this._filters)return;let e=Object.keys(this._filters);for(let t of e)this.executeAndAnalyseFilter(t)}executeAndAnalyseFilter(e){i(`Analysing filter "${e}"`),this._global.record=!0,this.executeFilter(e);let t=this._global.dependenciesFound;this._global.dependenciesFound=[];for(let s of t)if(this.checkForMissingDependency(s,e))return;this.populateDependencies(t,e),this._global.generatedFilters.push(this._name+e),i(`Generated ${e} for collection ${this._name}`)}executeFilter(e){this._executing=e;const t=Object.assign({data:this._public.data,filters:this._public.filters,groups:this._public.groups,actions:this._public.actions},this._global.dataRef,this._actionRefrence);let s=this._filters[e](t);this._executing=!1,this._global.record=!1,null==s&&(s=!1),this.deliverUpdate("filters",s,e)}buildGroupFromIndex(e){let t=this._indexes[e].map(e=>{let t=this._data[e];for(let e of Object.keys(this._relations)){let s=this._relations[e],i=!!s.hasOwnProperty("assignTo")&&s.assignTo;if(t.hasOwnProperty(e)){let r=this._global.internalDataRef[s.fromCollectionName][t[e]];r&&(i?t[i]=r:t[s.fromCollectionName]=r)}}return t});return(this._public.hasOwnProperty(e)||this._public.groups.hasOwnProperty(e))&&this.deliverUpdate("groups",t,e),this._allowInternalChange=!0,this._public.indexes[e]=this._indexes[e],this._allowInternalChange=!1,t}internalDataModified(e){this.findGroupsToRegen(e),this.findFiltersToRegen(e),this.regenerateGroupsAndFilters()}deliverUpdate(e,t,s){this._allowInternalChange=!0,this._public[e][s]=t,this._allowInternalChange=!1,this._public.hasOwnProperty(s)&&(this._allowInternalChange=!0,this._public[s]=t,this._allowInternalChange=!1),this.updateSubscribers(s,t)}updateSubscribers(e,t){if(i(`Updating subscribers for ${e}`),this.watchers.hasOwnProperty(e)&&setTimeout(()=>this.watchers[e](this._global.dataRef)),this.persistData(e,t),this._subscribedToData[e])for(let s of this._subscribedToData[e])s.component.$set(s.component,s.key,t)}recordHistory(e,t){let s={type:e,timestamp:Date.now(),collection:this._name,fromAction:this._performingAction,data:t};this._global.history.push(s)}populateDependencies(e,t){let s=this._global.dependencyGraph;for(let i of e){let e=`${i.collection}/${i.property}`,r=s[this._name][t];r.dependencies.includes(e)||r.dependencies.push(e);let o=`${this._name}/${t}`,n=s[i.collection][i.property];n&&n.dependents&&!n.dependents.includes(o)&&n.dependents.push(o)}}checkForMissingDependency(e,t){let s=this._global;return!(!s.allFilters.includes(e.property)||s.generatedFilters.includes(e.collection+e.property))&&(i(`Dependent "${e.property}" has not been analysed yet, saving this filter to regen queue.`),this._regenQueue.push({type:"filter",property:t,collection:this._name}),!0)}findAllDependents(e){const t=this._global.dependencyGraph,s=t[this._name][e].dependents,i=[];let o=0,n=[];for(let e of s)n.push(e),i.push(e);const a=()=>{o++;let e=n;n=[];for(let s of e){let e=this.parseKey(s),r=t[e.collection][e.property].dependents;for(let e of r)n.push(e),i.push(e)}if(o>1e3)return r("Maximum stack exceeded for dependent search.");0!==n.length&&a()};return a(),i}findAndUpdateDependents(e){let t=[];if(Array.isArray(e))for(let s of e){let e=this.findAllDependents(s);for(let s of e)t.includes(s)||t.push(s)}else t=this.findAllDependents(e);i(`Found dependents: ${JSON.stringify(t)}`),this.pushDependentsToRegenQueue(t)}pushDependentsToRegenQueue(e){for(let t of e){let e=this.parseKey(t);this._regenQueue.find(t=>t.property===e.property&&t.collection===e.collection)||this._regenQueue.push({type:"filter",property:e.property,collection:e.collection})}this._global.eventBus.message="processRegenQueue"}forceUpdate(e){this._regenQueue.push({type:"filter",property:e,collection:this._name}),this._global.eventBus.message="processRegenQueue"}collect(e,t){if(!e)return r(`Collect error on collection ${this._name}: Data undefined`);Array.isArray(e)||(e=[e]),this._collecting=!0;let s=!1,o=[],n=[];if(t)if(Array.isArray(t)){s=!0;for(let e of t)this.createRelationForIndex(e),this._indexesToRegen.push(e),this._indexes[e]||(this._indexes[e]=[]),o.push(e)}else this.createRelationForIndex(t),this._indexesToRegen.push(t),this._indexes[t]||(this._indexes[t]=[]),n.push(t);if(Array.isArray(e))for(let s of e)this.processDataItem(s,t,e);else this.processDataItem(e,t);this.recordHistory("collect",{dataCollected:e,indexesCreated:n,indexesModified:o}),this._collecting=!1,i(`Collected ${e.length} items. With index: ${t}`),this.regenerateGroupsAndFilters()}processDataItem(e,t){this._primaryKey||this.findPrimaryKey(e),e.hasOwnProperty(this._primaryKey)||this.dataRejectionHandler(e,"Primary key mismatch"),this._data[e[this._primaryKey]],t&&!this._indexes[t].includes(e[this._primaryKey])&&this._indexes[t].push(e[this._primaryKey]);for(let s of Object.keys(this._relations)){let i=this._relations[s];Array.isArray(i[t])&&i[t].push(e[s])}Object.keys(this._data).includes(e[this._primaryKey])&&this.findGroupsToRegen(e[this._primaryKey]),this.findFiltersToRegen(e[this._primaryKey],t),this._data[e[this._primaryKey]]=e,this._collectionSize++}findGroupsToRegen(e){i(`looking for indexes for ${e}`);let t=Object.keys(this._indexes);for(let s of t)this._indexes[s].includes(e)&&!this._indexesToRegen.includes(s)&&this._indexesToRegen.push(s)}findFiltersToRegen(e,t){const s=(e,t)=>{Object.keys(this[e]).forEach(s=>{this[e][s].includes(t)&&(this._filtersToForceRegen.includes(s)||this._filtersToForceRegen.push(s))})};if(Array.isArray(t))for(let e of t)s("_filtersRelatedToGroup",e);else s("_filtersRelatedToGroup",t);s("_filtersRelatedToData",e)}regenerateGroupsAndFilters(){for(let e of this._indexesToRegen){i(`Rebuilding index ${e}`);let t=this._indexesToRegen.shift();this.buildGroupFromIndex(t),this._global.dataRef[this._name][t]&&this.findAndUpdateDependents(t)}let e=[];for(let t of this._filtersToForceRegen)e.push(`${this._name}/${t}`);this.pushDependentsToRegenQueue(e),this._filtersToForceRegen=[]}undo(){i("undo requested, coming soon!")}move(e,t,s){if(!this._indexes[t])return r(`Index "${t}" not found`);if(!this._indexes[s])return r(`Index "${s}" not found`);Array.isArray(e)||(e=[e]);let i={ids:e,previousSourceIndex:t,previousDestIndex:s};for(let i of e){if(!this._data[i])return r(`Data for id "${i}" not found in collection ${this._name}`);this._indexes[t]=this._indexes[t].filter(e=>e!==i),this._indexes[s].push(i)}this.buildGroupFromIndex(t),this.buildGroupFromIndex(s),this.recordHistory("move",i),this.findAndUpdateDependents([t,s])}remove(e,t){if(!this._indexes[t])return r(`Group "${t}" not found.`);if(Array.isArray(e)||(e=[e]),e[0].hasOwnProperty(this._primaryKey))e=e.map(e=>e[this._primaryKey]);else if("number"!=typeof e[0])return r("Unable to remove data.");let s=this.indexes[t];this.indexes[t]=this.indexes[t].filter(t=>!e.includes(t)),this.buildGroupFromIndex(t),this.recordHistory("remove",{group:t,previousValue:s}),this.findAndUpdateDependents(t)}put(e,t){if(!this._indexes[t])return r(`Index "${t}" not found`);Array.isArray(e)||(e=[e]);let s=Object.assign({},this._indexes[t]);for(let s of e){if(!this._data[s])return r(`Data for id "${s}" not found in collection ${this._name}`);this._indexes[t].push(s)}this.buildGroupFromIndex(t),this.recordHistory("put",{ids:e,previousDestIndex:s}),this.findAndUpdateDependents(t)}update(e,t){if(this._data[e]){let s=this._data[e],i=Object.keys(t),o={dataId:e,previousValues:{},newValues:t};for(let n of i)s.hasOwnProperty(n)||r(`Data "${e}" does not have property "${n}" to update`),o.previousValues[n]=s[n],s[n]=t[n];this.recordHistory("update",o),this.internalDataModified(e)}else r(`Data for id "${e}" not found in collection ${this._name}`)}findById(e){if(this._executing&&(this._filtersRelatedToData[this._executing]=[e]),this._data[e])return this._data[e];i(`findByID: Item "${e}" not found in collection "${this._name}"`)}getGroup(e){return this._executing&&(this._filtersRelatedToGroup[this._executing]=[e]),this._indexes[e]?this.buildGroupFromIndex(e):[]}newGroup(e,t){Object.keys(this._indexes).includes(e)||(this._indexes[e]=t,this.recordHistory("newGroup",{createdGroup:e,data:t}))}modifyGroup(e){}delete(e){const t=e=>{let t=Object.assign({},this._data.primaryKey);delete this._data[e],this.recordHistory("delete",{deleted:t}),this.internalDataModified(e)};if(Array.isArray(e))for(let s of e)t(s);else t(e)}deleteGroup(e){if(!this._indexes[e])return r(`Group "${e}" not found.`);for(let t of this._indexes[e])this._data[t]&&delete this._data[t];let t=this._indexes[e];this._indexes[e]=[],this.buildGroupFromIndex(e),this.recordHistory("deleteGroup",{group:e,previousValue:t}),this.findAndUpdateDependents(e)}clean(){}increment(e,t,s){validateNumberForDataProperty(e,t,s)&&(this._data[e][t]+=s,this.recordHistory("increment",{previousValue:s}),this.internalDataModified(e))}decrement(e,t,s){validateNumberForDataProperty(e,t,s)&&(this._data[e][t]-=s,this.recordHistory("decrement",{previousValue:s}),this.internalDataModified(e))}throttle(e){let t=this._performingAction;this._throttles.push(t),setTimeout(()=>{this._throttles=this._throttles.filter(e=>e!==t)},e)}set(e,t){console.log(e,t)}validateNumberForDataProperty(e,t,s){return!(!this._data[e]||!this._data[e][t]||"number"!=typeof s||"number"!=typeof this._data[e][t])||(r(`Property ${t} for ${e} is not a number`),!1)}dataRejectionHandler(e,t){let s=`[Data Rejection] - ${t} - Data was not collected, but instead saved to the errors object("_errors") on root Pulse instance.`;this._global.errors.push({data:e,timestamp:new Date,error:s}),r(s)}parseKey(e){return{collection:e.split("/")[0],property:e.split("/")[1]}}}},function(e,t){e.exports={Log:e=>{},assert:e=>{},warn:e=>{console.error(`[Pulse] - ${e}`)}}},function(e,t,s){const i=s(3);e.exports={Library:i}},function(e,t,s){const{Log:i,assert:r,warn:o}=s(1),n=s(0),a=s(4),l=s(5);e.exports=class{constructor({collections:e={},utils:t={},services:s={},request:r={},storage:o,data:n={},groups:a=[],indexes:l=[],persist:h=[],actions:c={},filters:d={},watch:p={},routes:u={}}){window._pulse=this,this._collections=Object.create(null),this._subscribers=[],this._mappedProperties={},this._eventBus=this.activateEventBus(),this._global={regenQueue:[],errors:[],history:[],allFilters:[],collectionNamespace:[],updateSubscribers:this.updateSubscribers,eventBus:this._eventBus,dependenciesFound:[],dependencyGraph:{},generatedFilters:[],record:!1,initComplete:!1,request:{},dataRef:{},internalDataRef:{},storage:{},relations:{}},this.initStorage(o),this.initCollections(e,{data:n,indexes:l,actions:c,filters:d,routes:u,groups:a,watch:p,persist:h},r),this.buildGlobalDataRefrenceTree(),this.prepareDependencyGraph(),this.executeAllFilters(),this.processRegenQueue(),this._global.initComplete=!0,i("INIT_COMPLETE")}install(e){let t=this;e.mixin({beforeCreate(){Object.keys(t._global.dataRef).forEach(e=>{this["$"+e]=t._global.dataRef[e]}),this.mapData=t.mapData}})}mapData(e){const t={},s=window._pulse;return e&&s.normalizeMap(e).forEach(({key:e,val:i})=>{let r=i.split("/")[0],o=i.split("/")[1];if(!s.hasOwnProperty(r))return;let n=s._collections[r]._subscribedToData,a={component:this,key:e};n.hasOwnProperty(o)?n[o].push(a):n[o]=[a],t[e]=s[r][o]||null}),t}initVueAccessProxy(e){return new Proxy(e||{},{set:(e,t,s)=>(e[t]=s,!0)})}mapCollections(){const e={};return Object.keys(this._global.dataRef).forEach(t=>{e[t]=this._global.dataRef[t]}),e}normalizeMap(e){return Array.isArray(e)?e.map(e=>({key:e,val:e})):Object.keys(e).map(t=>({key:t,val:e[t]}))}activateEventBus(){return new Proxy({message:null},{set:(e,t,s)=>("processRegenQueue"===s&&this.processRegenQueue(),e[t]=s,!0)})}initStorage(e){let t="localStorage";if("sessionStorage"===e)this.assignStorage(sessionStorage,t),t="sessionStorage";else if(e&&e.set&&e.get&&e.remove)this.assignStorage(e,t),t="custom";else{if(!window.localStorage)return r("No storage API present, data will not persist");this.assignStorage(localStorage,t)}}assignStorage(e,t){const s={type:t};e.set&&(s.set=e.set.bind(e)),e.setItem&&(s.set=e.setItem.bind(e)),e.get&&(s.get=e.get.bind(e)),e.getItem&&(s.get=e.getItem.bind(e)),e.remove&&(s.remove=e.remove.bind(e)),e.removeItem&&(s.remove=e.removeItem.bind(e)),e.clear&&(s.clear=e.clear.bind(e)),this._global.storage=s}prepareDependencyGraph(){let e=this._global.dependencyGraph,t=this._global.collectionNamespace;for(let s of t){e[s]={};let t=this._collections[s]._public,i=[],r=["filters","groups","data"];for(let e of r)Object.keys(t[e]).forEach(e=>i.push(e));for(let t of i)e[s][t]={dependencies:[],dependents:[]}}}initCollections(e,t,s){this._collections.base=new a(this._global,t,s),this._collections.request=new l(this._global,s),this._global.collectionNamespace=["base","request"],Object.keys(e).forEach(t=>{this._global.collectionNamespace.push(t),this._collections[t]=new n({name:t,global:this._global},e[t])}),Object.keys(this._collections).forEach(e=>{this[e]?r(`Collection name conflict, instance already has "${e}" thus it will not be accessable on the root state tree.`):this[e]=this._collections[e]._public})}buildGlobalDataRefrenceTree(){if(this._collections){let e=Object.keys(this._collections);for(let t of e)this._global.dataRef[t]=this._collections[t]._public}}executeAllFilters(){let e=Object.keys(this._collections);for(let t of e)this._collections[t].analyseFilters()}processRegenQueue(){if(0!==this._global.regenQueue.length){i(`Regen queue processing. There are ${this._global.regenQueue.length} in the queue.`);for(let e of this._global.regenQueue){const e=this._global.regenQueue.shift(),t=`${e.collection}/${e.property}`;if(t===this.lastRegenerated)return o(`Prevented infinate loop for ${t}`),void(this.lastRegenerated="");this._collections[e.collection].executeAndAnalyseFilter(e.property),this.lastRegenerated=t,i(`There are ${this._global.regenQueue.length} properties left to regenerate.`)}this._global.regenQueue.length>0?this.processRegenQueue():this.lastRegenerated=""}}collect(e,t){this._collections.root.collect(e,t)}processCallbacks(e){return!!self._subscribers.length&&(this._subscribers.forEach(t=>t(e)),!0)}}},function(e,t,s){const i=s(0);e.exports=class extends i{constructor(e,{data:t={},actions:s={},routes:i={},filters:r={},groups:o=[],watch:n={},persist:a=[]}){t.isAuthenticated=!1,t.appReady=!1,t.pendingRequests=[],a.push("isAuthenticated"),super({name:"base",global:e},{data:t,actions:s,groups:o,persist:a,routes:i,filters:r,watch:n})}}},function(e,t,s){const i=s(0);e.exports=class extends i{constructor(e,{baseURL:t,requestIntercept:s,responseIntercept:i,mode:r,credentials:o,headers:n}){let a={baseURL:t,mode:"cors",credentials:"include"};t||(a.baseURL=null),super({name:"request",global:e},{groups:["history"],data:a,persist:["baseURL"]});this.standardHeader={headers:{"Content-Type":"application/json",Accept:"application/json"}},o&&(a.credentials=o),r&&(a.mode=r),this.standardHeader.credentials=a.credentials,this.standardHeader.mode=a.mode,n&&Object.keys(n).forEach(e=>{this.standardHeader.headers[e]=n[e]}),this._global.request={get:this.get.bind(this),post:this.post.bind(this),put:this.put.bind(this),patch:this.patch.bind(this),delete:this.delete.bind(this)}}send(e,t,s,i){return new Promise((r,o)=>{let n=this.standardHeader;i&&Object.keys(i).forEach(e=>{n.headers[e]=i[e]});let a=`${this._global.dataRef.request.baseURL}/${e}`;s=JSON.stringify(s);const l=Object.assign(n,{method:t.toUpperCase(),body:"get"==t?null:s});fetch(a,l).then(e=>{const t=e.headers.get("content-type");return t&&-1!==t.indexOf("application/json")?e.json():e.text()}).then(e=>{console.log("[API RESPONSE]",e),this.collect({id:Date.now(),status:e.status,timestamp:new Date,response:e},"history"),e.status&&e.status.code&&(e.status.code.toString().startsWith("4")||e.status.code.toString().startsWith("5"))&&o(e),r(e)}).catch(o)})}get(e,t){return this.send(e,"get",{},t)}post(e,t,s){return this.send(e,"post",t,s)}patch(e,t,s){return this.send(e,"patch",t,s)}delete(e,t,s){return this.send(e,"delete",t,s)}put(e,t,s){return this.send(e,"put",t,s)}}}]));