(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.Pulse = factory());
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var Dep = /** @class */ (function () {
        function Dep(global, 
        // if this dep is for public or internal data within a collection
        type, 
        // the name of the coll
        parentModuleInstance, 
        // either the name of the object if reactive or the primaryKey if internal
        propertyName, 
        // if the dep is part of a deep reactive object, this is the root property name
        rootProperty) {
            if (type === void 0) { type = 'reactive'; }
            if (rootProperty === void 0) { rootProperty = null; }
            this.global = global;
            this.type = type;
            this.parentModuleInstance = parentModuleInstance;
            this.propertyName = propertyName;
            this.rootProperty = rootProperty;
            // these
            this.dependents = new Set();
            this.subscribers = new Set();
            // these are temporary relations created by the relation controller
            this.dynamicRelation = null;
            // used to stop computed methods from tracking properties accessed within nested actions as dependecies
            this.currentActionIndex = false;
            this.subscribersToInternalDataAsCallbacks = [];
        }
        // for when public data is accessed, reactive class will trigger this function
        Dep.prototype.register = function () {
            var subs = this.global.subs;
            var name = this.propertyName;
            if (this.type === 'reactive') {
                if (this.global.runningComputed && !this.global.runningWatcher) {
                    // register dependent
                    this.dependents.add(this.global.runningComputed);
                    // if this property is a computed function that has not ran at least once
                    if (this.parentModuleInstance.keys.computed.includes(this
                        .propertyName) &&
                        !this.parentModuleInstance.isComputedReady(this
                            .propertyName)) {
                        // re-queue the computed function that is currently running
                        // (not the one that is being accessed) this will give the unready computed
                        // function a chance to run before this one is ran again, since runningComputed depends on the
                        // output of this computed function
                        // console.log('reingesting');
                        this.global.runtime.ingest({
                            type: JobType.COMPUTED_REGEN,
                            property: this.global.runningComputed,
                            collection: this.parentModuleInstance
                        });
                    }
                }
            }
            else if (this.type === 'internal') {
                var dataDep = this.global.runningPopulate;
                // if the data's dep class
                // action index matches the current action, create dynamic relation
                if (dataDep &&
                    dataDep.currentActionIndex === this.global.runtime.runningActions.length)
                    this.global.relations.relate(dataDep, this);
            }
            if (this.global.subs.trackingComponent)
                this.subscribe(this.global.subs.trackingComponent);
            if (subs.unsubscribingComponent) ;
        };
        Dep.prototype.changed = function (newValue, config) {
            if (config === void 0) { config = {}; }
            var collection = this.parentModuleInstance;
            if (this.dynamicRelation)
                this.global.relations.cleanup(this.dynamicRelation);
            if (this.type === 'internal') {
                // get dynamic data
                var dataWithDynamicProperties_1 = collection.injectDynamicRelatedData(newValue[collection.primaryKey], newValue);
                // run all callbacks and pass in dynamic data, unless important
                this.subscribersToInternalDataAsCallbacks.forEach(function (callback) {
                    return callback(config.important
                        ? __assign({}, dataWithDynamicProperties_1, newValue) : dataWithDynamicProperties_1);
                });
            }
        };
        Dep.prototype.subscribe = function (componentContainer) {
            if (!this.global.runtime.runningAction)
                this.subscribers.add(componentContainer);
        };
        return Dep;
    }());
    //# sourceMappingURL=Dep.js.map

    var Computed = /** @class */ (function () {
        function Computed(global, parentModuleInstance, name, computedFunction) {
            this.global = global;
            this.parentModuleInstance = parentModuleInstance;
            this.name = name;
            this.computedFunction = computedFunction;
            this.relatedToGroup = [];
            this.dynamicRelation = null;
            this.hasRun = false;
        }
        Computed.prototype.run = function () {
            this.hasRun = true;
            this.global.relations.cleanup(this.dynamicRelation);
            this.global.runningComputed = this;
            var context = this.global.getContext(this.parentModuleInstance);
            var output;
            try {
                output = this.computedFunction(context);
            }
            catch (error) {
                // during init computed functions that depend on the output of other computed functions will
                // throw an error, we want to ingore this error and
                if (this.global.initComplete)
                    console.error(error);
            }
            // override output with default if undefined or null
            if ((output === undefined || output === null) &&
                this.global.config.computedDefault)
                output = this.global.config.computedDefault;
            this.global.runningComputed = false;
            return output;
        };
        return Computed;
    }());
    //# sourceMappingURL=computed.js.map

    var DynamicRelation = /** @class */ (function () {
        function DynamicRelation(updateThis) {
            this.updateThis = updateThis;
            this.depsToClean = new Set();
        }
        // perform cleanup of all references to this instance
        DynamicRelation.prototype.destroy = function () {
            var _this = this;
            this.depsToClean.forEach(function (dep) { return dep.dependents.delete(_this); });
            delete this.updateThis.dynamicRelation;
        };
        return DynamicRelation;
    }());
    var RelationController = /** @class */ (function () {
        function RelationController(global) {
            this.global = global;
            this.relationBank = new Set();
        }
        // function called during runningComputed and runningPopulate
        RelationController.prototype.relate = function (updateThis, whenDepChanges) {
            if (!whenDepChanges)
                return; // if a dep is not found, abort
            var dep = whenDepChanges;
            if (!updateThis.dynamicRelation) {
                updateThis.dynamicRelation = new DynamicRelation(updateThis);
                this.relationBank.add(updateThis.dynamicRelation);
            }
            // save Dep inside relation so relation knows where to remove dependent from on cleanup
            updateThis.dynamicRelation.depsToClean.add(dep);
            // add dynamic relation as a dependent inside Dep
            dep.dependents.add(updateThis.dynamicRelation);
        };
        // when a job is complete with a dep that includes a dynamic
        RelationController.prototype.cleanup = function (dynamicRelation) {
            // perform cleanup, destroy dynamic relation
            if (!dynamicRelation)
                return;
            dynamicRelation.destroy(); // destroy all references
            this.relationBank.delete(dynamicRelation); // remove last reference from bank
        };
        return RelationController;
    }());
    var RelationTypes;
    (function (RelationTypes) {
        RelationTypes["COMPUTED_DEPENDS_ON_DATA"] = "COMPUTED_DEPENDS_ON_DATA";
        RelationTypes["COMPUTED_DEPENDS_ON_GROUP"] = "COMPUTED_DEPENDS_ON_GROUP";
        RelationTypes["DATA_DEPENDS_ON_DEP"] = "DATA_DEPENDS_ON_DEP";
        RelationTypes["DATA_DEPENDS_ON_GROUP"] = "DATA_DEPENDS_ON_GROUP";
        RelationTypes["DATA_DEPENDS_ON_DATA"] = "DATA_DEPENDS_ON_DATA"; // used by findById() when run in populate()
    })(RelationTypes || (RelationTypes = {}));
    //# sourceMappingURL=relationController.js.map

    var JobType;
    (function (JobType) {
        JobType["PUBLIC_DATA_MUTATION"] = "PUBLIC_DATA_MUTATION";
        JobType["INTERNAL_DATA_MUTATION"] = "INTERNAL_DATA_MUTATION";
        JobType["INDEX_UPDATE"] = "INDEX_UPDATE";
        JobType["COMPUTED_REGEN"] = "COMPUTED_REGEN";
        JobType["GROUP_UPDATE"] = "GROUP_UPDATE";
        JobType["SOFT_GROUP_UPDATE"] = "SOFT_GROUP_UPDATE";
        JobType["DELETE_INTERNAL_DATA"] = "DELETE_INTERNAL_DATA";
    })(JobType || (JobType = {}));
    var Runtime = /** @class */ (function () {
        function Runtime(collections, global) {
            this.collections = collections;
            this.global = global;
            this.updatingSubscribers = false;
            this.runningJob = false;
            this.ingestQueue = [];
            this.completedJobs = [];
            this.archivedJobs = [];
            // global action state
            this.runningActions = [];
            this.runningAction = false;
            global.ingest = this.ingest.bind(this);
            global.ingestDependents = this.ingestDependents.bind(this);
            this.config = global.config;
        }
        // The primary entry point for Runtime, all jobs should come through here
        Runtime.prototype.ingest = function (job) {
            // if last job is identical to current job
            // since completed jobs is cleared after a component update is issued this SHOULDN't prevent
            // the same thing happening twice (pls test tho)
            // if (
            //   this.runningJob &&
            //   job.property === (this.runningJob as Job).property &&
            //   job.collection === (this.runningJob as Job).collection
            // ) {
            //   // console.error('Pulse: Infinate job loop prevented', job);
            //   // return;
            // }
            this.ingestQueue.push(job);
            // don't begin the next job until this one is fully complete
            if (!this.runningJob) {
                this.findNextJob();
            }
        };
        Runtime.prototype.queue = function (job) {
            this.ingestQueue.push(job);
        };
        Runtime.prototype.run = function () {
            if (!this.runningJob)
                this.findNextJob();
        };
        Runtime.prototype.findNextJob = function () {
            // shift the next job from the queue
            var next = this.ingestQueue.shift();
            if (!next)
                return;
            this.global.log(next);
            if (!next.dep && next.type !== JobType.INDEX_UPDATE)
                // groups, computed and indexes will not have their Dep class, so get it.
                next.dep = next.collection.getDep(next.property);
            this.runningJob = next;
            // execute the next task in the queue
            this.performJob(next);
        };
        Runtime.prototype.loadPreviousValue = function (job) {
            var location;
            if (job.type === JobType.INDEX_UPDATE)
                location = 'indexes';
            else if (job.type === JobType.COMPUTED_REGEN ||
                job.type === JobType.SOFT_GROUP_UPDATE)
                location = 'public';
            return job.collection[location].privateGet(job.property);
        };
        Runtime.prototype.performJob = function (job) {
            var pre = job.hasOwnProperty(job.previousValue);
            switch (job.type) {
                case JobType.PUBLIC_DATA_MUTATION:
                    this.performPublicDataUpdate(job);
                    job.collection.runWatchers(job.property);
                    break;
                case JobType.INTERNAL_DATA_MUTATION:
                    this.performInternalDataUpdate(job);
                    break;
                case JobType.INDEX_UPDATE:
                    // if (!pre) job.previousValue = this.loadPreviousValue(job);
                    this.performIndexUpdate(job);
                    break;
                case JobType.COMPUTED_REGEN:
                    // if (!pre) job.previousValue = this.loadPreviousValue(job);
                    this.performComputedOutput(job);
                    job.collection.runWatchers(job.property.name);
                    break;
                case JobType.GROUP_UPDATE:
                    this.performGroupRebuild(job);
                    job.collection.runWatchers(job.property);
                    break;
                case JobType.SOFT_GROUP_UPDATE:
                    // if (!pre) job.previousValue = this.loadPreviousValue(job);
                    this.performGroupRebuild(job);
                    job.collection.runWatchers(job.property);
                    break;
                case JobType.DELETE_INTERNAL_DATA:
                    this.performInternalDataDeletion(job);
                    break;
                default:
                    break;
            }
            // unpack dependents
            if (job.dep && job.dep.dependents.size > 0) {
                this.ingestDependents(job.dep.dependents);
            }
            this.finished();
        };
        Runtime.prototype.ingestDependents = function (dependents) {
            var _this = this;
            // this is called twice below
            var ingestComputed = function (computed) {
                return _this.ingest({
                    type: JobType.COMPUTED_REGEN,
                    collection: computed.parentModuleInstance,
                    property: computed,
                    dep: computed.parentModuleInstance.getDep(computed.name)
                });
            };
            // for each dependent stored in dep class
            dependents.forEach(function (dependent) {
                // there are two types of dependents stored: Computed and DynamicRelation
                if (dependent instanceof Computed)
                    ingestComputed(dependent);
                else if (dependent instanceof DynamicRelation) {
                    // one might think using "instanceOf" would work as expected below
                    // but it doesn't, alas I hate javascript.
                    // temp fix: constructor.name - be my guest try and fix this??
                    var type = dependent.updateThis.constructor.name;
                    // DynamicRelation can store either Computed or Dep (internal)
                    if (type === Computed.name)
                        ingestComputed(dependent.updateThis);
                    else if (type === Dep.name) {
                        // ingest internal data mutation without a value will result in a soft group update
                        _this.ingest({
                            type: JobType.INTERNAL_DATA_MUTATION,
                            collection: dependent.updateThis.parentModuleInstance,
                            property: dependent.updateThis.propertyName
                        });
                    }
                }
            });
        };
        // handle job loop flow
        Runtime.prototype.finished = function () {
            var _this = this;
            this.runningJob = false;
            if (this.completedJobs.length > 5000)
                return;
            // If there's already more stuff in the queue, loop.
            if (this.ingestQueue.length > 0) {
                this.findNextJob();
                return;
            }
            // Wait until callstack is empty to check if we should finalise this body of work
            setTimeout(function () {
                if (_this.ingestQueue.length === 0) {
                    if (!_this.updatingSubscribers)
                        _this.compileComponentUpdates();
                    _this.cleanup();
                }
                else {
                    // loop more!
                    _this.findNextJob();
                }
            });
        };
        // ****************** Perform Functions ****************** //
        Runtime.prototype.performPublicDataUpdate = function (job) {
            job.collection.public.privateWrite(job.property, job.value);
            this.completedJob(job);
        };
        Runtime.prototype.performInternalDataUpdate = function (job) {
            var _this = this;
            // if job was not ingested with a value, get the most recent value from collection database
            var collection = job.collection;
            var property = job.property;
            if (!job.value) {
                if (collection.internalData[property])
                    job.value = collection.internalData[property];
                // this would usually be redundant, since the data has not changed, but since the relationController has no access to the collections, but does need to trigger data to rebuild, it issues an internal data "update". It's own data has not changed, but the dynamic data related to it via populate() has.
            }
            // overwrite or insert the data into collection database
            this.overwriteInternalData(collection, job.property, job.value);
            // collection function handels ingesting indexes to update itself, since it waits until
            // all internal data has been ingested before handling the affected indexes
            // however for direct data modifications we should update afected indexes
            if (!this.global.collecting) {
                // affected indexes is an array of indexes that have this primary key (job.property) present.
                var affectedIndexes = collection.searchIndexesForPrimaryKey(property);
                affectedIndexes.forEach(function (index) {
                    // since this is a singular piece of data that has changed, we do not need to
                    // rebuild the entire group, so we can soft rebuild
                    var modifiedGroup = collection.softUpdateGroupData(property, index);
                    _this.ingest({
                        type: JobType.SOFT_GROUP_UPDATE,
                        collection: collection,
                        value: modifiedGroup,
                        property: index,
                        dep: collection.getDep(index)
                        // we do not need a previousValue because groups are cached outputs and reversing the internal data update will do the trick
                    });
                });
            }
            this.completedJob(job);
        };
        Runtime.prototype.performInternalDataDeletion = function (job) {
            var c = job.collection;
            var property = job.property;
            // preserve previous value
            // job.previousValue = { ...c.internalData[job.property] };
            // delete data
            delete c.internalData[property];
            // find indexes affected by this data deletion
            var indexesToUpdate = c.searchIndexesForPrimaryKey(property);
            // for each found index, perform index update
            for (var i = 0; i < indexesToUpdate.length; i++) {
                var indexName = indexesToUpdate[i];
                var newIndex = c.indexes.object[indexName].slice().filter(function (id) { return id !== job.property; });
                this.ingest({
                    type: JobType.INDEX_UPDATE,
                    collection: c,
                    property: indexName,
                    value: newIndex,
                    dep: c.getDep(job.property)
                });
            }
            this.completedJob(job);
        };
        Runtime.prototype.performIndexUpdate = function (job) {
            // Update Index
            var c = job.collection;
            c.indexes.privateWrite(job.property, job.value);
            this.completedJob(job);
            // Group must also be updated
            this.ingest({
                type: JobType.GROUP_UPDATE,
                collection: job.collection,
                property: job.property,
                dep: job.collection.getDep(job.property)
            });
        };
        Runtime.prototype.performGroupRebuild = function (job) {
            var c = job.collection;
            var property = job.property;
            // soft group rebuilds already have a generated value, otherwise generate the value
            if (!job.value) {
                job.value = c.buildGroupFromIndex(property);
            }
            // TODO: trigger relaction controller to update group relations
            // this.global.relations.groupModified(job.collection, job.property);
            job.collection.public.privateWrite(job.property, job.value);
            this.completedJob(job);
        };
        Runtime.prototype.performComputedOutput = function (job) {
            var computed = typeof job.property === 'string'
                ? job.collection.computed[job.property]
                : job.property;
            job.value = computed.run();
            // Commit Update
            job.collection.public.privateWrite(computed.name, job.value);
            this.completedJob(job);
        };
        // ****************** Handlers ****************** //
        Runtime.prototype.completedJob = function (job) {
            // if action is running, save that action instance inside job payload
            job.fromAction = this.runningAction;
            // during runtime log completed job ready for component updates
            if (this.global.initComplete)
                this.completedJobs.push(job);
            // if data is persistable ensure storage is updated with new data
            this.persistData(job);
            // tell the dep the parent changed
            if (job.dep)
                job.dep.changed(job.value, job.config);
            // if running action save this job inside the action class
            if (this.runningAction)
                this.runningAction.changes.add(job);
        };
        // ****************** End Runtime Events ****************** //
        Runtime.prototype.compileComponentUpdates = function () {
            if (!this.global.initComplete)
                return;
            this.updatingSubscribers = true;
            this.global.log('ALL JOBS COMPLETE', this.completedJobs);
            var componentsToUpdate = {};
            var _loop_1 = function (i) {
                var job = this_1.completedJobs[i];
                // if job has a Dep class present
                // Dep class contains subscribers to that property (as a completed job)
                if (job.dep) {
                    var subscribers = job.dep.subscribers;
                    // for all the subscribers
                    subscribers.forEach(function (componentContainer) {
                        // add to componentsToUpdate (ensuring update & component is unique)
                        var uuid = componentContainer.uuid;
                        var key = componentContainer.key;
                        // below is a band-aid, caused by (what I believe to be) deep reactive properties submitting several updates for the same mutation, one for each level deep, since the parent is triggered as well
                        // if (!key) continue;
                        if (!key) {
                            if (!componentsToUpdate[uuid])
                                componentsToUpdate[uuid] = false; // will cause blind re-render
                        }
                        else {
                            // if this component isn't already registered for this particular update, add it.
                            if (!componentsToUpdate[uuid]) {
                                componentsToUpdate[uuid] = {};
                                componentsToUpdate[uuid][key] = job.value;
                                // otherwise add the update to the component
                            }
                            else {
                                componentsToUpdate[uuid][key] = job.value;
                            }
                        }
                    });
                }
            };
            var this_1 = this;
            // for all completed jobs
            for (var i = 0; i < this.completedJobs.length; i++) {
                _loop_1(i);
            }
            this.updateSubscribers(componentsToUpdate);
            this.completedJobs = [];
        };
        Runtime.prototype.updateSubscribers = function (componentsToUpdate) {
            // console.log('updating subscribers', componentsToUpdate);
            var componentKeys = Object.keys(componentsToUpdate);
            var _loop_2 = function (i) {
                var componentID = componentKeys[i];
                var componentInstance = this_2.global.subs.componentStore[componentID];
                if (!componentInstance || !componentInstance.instance)
                    return { value: void 0 };
                var propertiesToUpdate = componentsToUpdate[componentID];
                var dataKeys = [];
                if (propertiesToUpdate)
                    dataKeys = Object.keys(propertiesToUpdate);
                // Switch depending on framework
                switch (this_2.global.config.framework) {
                    case 'vue':
                        dataKeys.forEach(function (property) {
                            var value = propertiesToUpdate[property];
                            componentInstance.instance.$set(componentInstance.instance, property, 
                            // this prevents vue from adding getters/setters to any objects, but might be wasteful computation
                            // considering this is not important and does not change perfomance, its probably best to not bother cleansing every
                            // value update. actually thinking about it this is terrbile. remove this soon.
                            // honestly it's only here because I have OCD.
                            // cleanse(value)
                            value);
                        });
                        break;
                    case 'react':
                        componentInstance.config.blindSubscribe
                            ? componentInstance.instance.forceUpdate()
                            : componentInstance.instance.setState(propertiesToUpdate);
                        break;
                    default:
                        break;
                }
            };
            var this_2 = this;
            for (var i = 0; i < componentKeys.length; i++) {
                var state_1 = _loop_2(i);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        };
        // TODO: add moduleType to module class and store persist keys with that in mind, since persisting data won't work for modules with the same name, although devs should not be creating modules with the same name, i don't even think thats possible
        Runtime.prototype.persistData = function (job) {
            if (job.type === JobType.INTERNAL_DATA_MUTATION)
                return;
            if (job.collection.persist.includes(job.property)) {
                this.global.storage.set(job.collection.name, job.property, job.value);
            }
        };
        Runtime.prototype.cleanup = function () {
            var _this = this;
            setTimeout(function () {
                _this.updatingSubscribers = false;
            });
        };
        // ****************** Misc Handlers ****************** //
        Runtime.prototype.overwriteInternalData = function (collection, primaryKey, newData) {
            var internalData = collection.internalData;
            // create a copy of the original data
            var currentData = internalData[primaryKey]
                ? __assign({}, internalData[primaryKey]) : false;
            if (currentData) {
                // data already exists, merge objects and return previous object
                var keys = Object.keys(newData || {});
                for (var i = 0; i < keys.length; i++) {
                    var property = keys[i];
                    internalData[primaryKey][property] = newData[property];
                }
                return currentData;
            }
            else {
                // data does not exist, write and return false
                internalData[primaryKey] = newData;
                return false;
            }
        };
        return Runtime;
    }());
    //# sourceMappingURL=runtime.js.map

    var protectedNames = [
        'data',
        'indexes',
        'groups',
        'computed',
        'actions',
        'routes'
    ];
    var collectionFunctions = [
        'collect',
        'replaceIndex',
        'getGroup',
        'newGroup',
        'deleteGroup',
        'removeFromGroup',
        'update',
        'increment',
        'decrement',
        'delete',
        'purge',
        'watch',
        'findById',
        'put',
        'move',
        'throttle',
        'forceUpdate',
        'debounce',
        'watchData',
        'cleanse',
        // 'unsubscribe',
        // deprecated
        'remove'
    ];
    function defineConfig(config, defaults) {
        return __assign({}, defaults, config);
    }
    function genId() {
        return (Math.random()
            .toString()
            .split('.')[1] + Date.now());
    }
    function isWatchableObject(value) {
        function isHTMLElement(obj) {
            try {
                return obj instanceof HTMLElement;
            }
            catch (e) {
                return (typeof obj === 'object' &&
                    obj.nodeType === 1 &&
                    typeof obj.style === 'object' &&
                    typeof obj.ownerDocument === 'object');
            }
        }
        var type = typeof value;
        return (value != null &&
            type == 'object' &&
            !isHTMLElement(value) &&
            !Array.isArray(value));
    }
    // const thing = {}
    // objectLoop(thing, (thingKey, thingItem) => {
    // })
    function log(value, payload) {
        // console.log(`Pulse / ${value}`, payload ? payload : ' ');
    }
    var arrayFunctions = [
        'push',
        'pop',
        'shift',
        'unshift',
        'splice',
        'sort',
        'reverse'
    ];
    function assert(func, funcName) {
        function warn(message) {
            // if (funcName) console.log(`PULSE // "${funcName}()" :: ${message}`);
            // else console.warn(`PULSE :: ${message}`);
            return false;
        }
        var warnings = {
            NO_PRIMARY_KEY: function () { return warn(); },
            INVALID_PARAMETER: function () { return warn(); },
            INDEX_NOT_FOUND: function () { return warn(); },
            INTERNAL_DATA_NOT_FOUND: function () { return warn(); },
            PROPERTY_NOT_A_NUMBER: function () { return warn(); }
        };
        return func(warnings)();
    }
    function validateNumber(mutable, amount) {
        if (typeof amount !== 'number' || typeof mutable !== 'number') {
            return false;
        }
        return true;
    }
    function createObj(array, sourceObject) {
        if (array === void 0) { array = []; }
        if (sourceObject === void 0) { sourceObject = {}; }
        var newObj = {};
        for (var i = 0; i < array.length; i++) {
            var property = array[i];
            if (sourceObject[property])
                newObj[property] = sourceObject[property];
        }
        return newObj;
    }
    // groups are defined by the user as an array of strings, this converts them into object/keys
    function normalizeGroups(groupsAsArray) {
        if (groupsAsArray === void 0) { groupsAsArray = []; }
        var groups = {};
        for (var i = 0; i < groupsAsArray.length; i++) {
            var groupName = groupsAsArray[i];
            groups[groupName] = [];
        }
        return groups;
    }
    //# sourceMappingURL=helpers.js.map

    var Dep$1 = /** @class */ (function () {
        function Dep(global, 
        // if this dep is for public or internal data within a collection
        type, 
        // the name of the coll
        parentModuleInstance, 
        // either the name of the object if reactive or the primaryKey if internal
        propertyName, 
        // if the dep is part of a deep reactive object, this is the root property name
        rootProperty) {
            if (type === void 0) { type = 'reactive'; }
            if (rootProperty === void 0) { rootProperty = null; }
            this.global = global;
            this.type = type;
            this.parentModuleInstance = parentModuleInstance;
            this.propertyName = propertyName;
            this.rootProperty = rootProperty;
            // these
            this.dependents = new Set();
            this.subscribers = new Set();
            // these are temporary relations created by the relation controller
            this.dynamicRelation = null;
            // used to stop computed methods from tracking properties accessed within nested actions as dependecies
            this.currentActionIndex = false;
            this.subscribersToInternalDataAsCallbacks = [];
        }
        // for when public data is accessed, reactive class will trigger this function
        Dep.prototype.register = function () {
            var subs = this.global.subs;
            var name = this.propertyName;
            if (this.type === 'reactive') {
                if (this.global.runningComputed && !this.global.runningWatcher) {
                    // register dependent
                    this.dependents.add(this.global.runningComputed);
                    // if this property is a computed function that has not ran at least once
                    if (this.parentModuleInstance.keys.computed.includes(this
                        .propertyName) &&
                        !this.parentModuleInstance.isComputedReady(this
                            .propertyName)) {
                        // re-queue the computed function that is currently running
                        // (not the one that is being accessed) this will give the unready computed
                        // function a chance to run before this one is ran again, since runningComputed depends on the
                        // output of this computed function
                        // console.log('reingesting');
                        this.global.runtime.ingest({
                            type: JobType.COMPUTED_REGEN,
                            property: this.global.runningComputed,
                            collection: this.parentModuleInstance
                        });
                    }
                }
            }
            else if (this.type === 'internal') {
                var dataDep = this.global.runningPopulate;
                // if the data's dep class
                // action index matches the current action, create dynamic relation
                if (dataDep &&
                    dataDep.currentActionIndex === this.global.runtime.runningActions.length)
                    this.global.relations.relate(dataDep, this);
            }
            if (this.global.subs.trackingComponent)
                this.subscribe(this.global.subs.trackingComponent);
            if (subs.unsubscribingComponent) ;
        };
        Dep.prototype.changed = function (newValue, config) {
            if (config === void 0) { config = {}; }
            var collection = this.parentModuleInstance;
            if (this.dynamicRelation)
                this.global.relations.cleanup(this.dynamicRelation);
            if (this.type === 'internal') {
                // get dynamic data
                var dataWithDynamicProperties_1 = collection.injectDynamicRelatedData(newValue[collection.primaryKey], newValue);
                // run all callbacks and pass in dynamic data, unless important
                this.subscribersToInternalDataAsCallbacks.forEach(function (callback) {
                    return callback(config.important
                        ? __assign({}, dataWithDynamicProperties_1, newValue) : dataWithDynamicProperties_1);
                });
            }
        };
        Dep.prototype.subscribe = function (componentContainer) {
            if (!this.global.runtime.runningAction)
                this.subscribers.add(componentContainer);
        };
        return Dep;
    }());
    //# sourceMappingURL=dep.js.map

    var Reactive = /** @class */ (function () {
        function Reactive(parentModuleInstance, object, mutableProperties, type) {
            if (object === void 0) { object = {}; }
            if (type === void 0) { type = 'public'; }
            this.parentModuleInstance = parentModuleInstance;
            this.mutableProperties = mutableProperties;
            this.type = type;
            this.ghosts = {}; // used by indexes only
            this.allowPrivateWrite = false;
            this.touching = false;
            this.tempDeps = {};
            this.global = parentModuleInstance.global;
            this.properties = Object.keys(object).concat(mutableProperties);
            this.object = this.reactiveObject(object);
        }
        Reactive.prototype.reactiveObject = function (object, rootProperty) {
            var objectKeys = rootProperty ? Object.keys(object) : this.properties;
            // Loop over all properties of the to-be reactive object
            for (var i = 0; i < objectKeys.length; i++) {
                var key = objectKeys[i];
                this.defineProperty(object, key, rootProperty);
            }
            return object;
        };
        Reactive.prototype.defineProperty = function (object, key, rootProperty) {
            var self = this;
            var value = object[key];
            if (object.rootProperty)
                rootProperty = object.rootProperty;
            // // If property is an array, make it reactive
            // if (Array.isArray(value)) {
            //   // value = this.reactiveArray(value, key);
            // }
            // rootProperty should be the current key if first deep object
            if (isWatchableObject(value) && !protectedNames.includes(key)) {
                value = this.deepReactiveObject(value, rootProperty || key, key);
            }
            // Create an instance of the dependency tracker
            var dep = this.createDep(key, rootProperty);
            Object.defineProperty(object, key, {
                get: function pulseGetter() {
                    if (self.sneaky || self.global.gettingContext)
                        return value;
                    if (self.global.touching) {
                        self.global.touched = dep;
                        return value;
                    }
                    dep.register();
                    return value;
                },
                set: function pulseSetter(newValue) {
                    // DEEP REACTIVE handler: "rootProperty" indicates if the object is "deep".
                    if (rootProperty && self.mutableProperties.includes(rootProperty)) {
                        // mutate locally
                        value = newValue;
                        // ingest mutation for deep property
                        self.global.runtime.ingest({
                            type: JobType.PUBLIC_DATA_MUTATION,
                            collection: self.parentModuleInstance,
                            property: rootProperty,
                            value: self.object[rootProperty],
                            dep: dep
                        });
                        // Regular mutations
                    }
                    else {
                        // if a protected name allow direct mutation
                        if (protectedNames.includes(key)) {
                            return (value = newValue);
                        }
                        // if backdoor open allow direct mutation
                        if (self.allowPrivateWrite) {
                            // dynamically convert new values to reactive if objects
                            // This is risky as fuck and kinda doesn't even work
                            if (isWatchableObject(newValue) && self.properties.includes(key)) {
                                newValue = self.deepReactiveObject(newValue, rootProperty || key, key);
                            }
                            return (value = newValue);
                        }
                        // if property is mutable dispatch update
                        if (self.properties.includes(key)) {
                            self.global.runtime.ingest({
                                type: JobType.PUBLIC_DATA_MUTATION,
                                collection: self.parentModuleInstance,
                                property: key,
                                value: newValue,
                                dep: dep
                            });
                            // we did not apply the mutation since runtime will privately
                            // write the result since we dispatched above
                        }
                    }
                }
            });
            return object;
        };
        Reactive.prototype.addProperty = function (key, value) {
            this.object[key] = value;
            this.defineProperty(this.object, key);
        };
        Reactive.prototype.tempDep = function (property) {
            var dep = this.createDep(property);
            this.tempDeps[property] = dep;
            return dep;
        };
        Reactive.prototype.cloneDep = function (dep) {
            dep = Object.assign(Object.create(Object.getPrototypeOf(dep)), dep);
            // delete this.tempDeps[dep.propertyName];
            return dep;
        };
        Reactive.prototype.createDep = function (key, rootProperty) {
            var dep;
            if (this.tempDeps.hasOwnProperty(key) && !rootProperty) {
                dep = this.cloneDep(this.tempDeps[key]);
            }
            else {
                dep = new Dep$1(this.global, this.type === 'indexes' ? 'index' : 'reactive', this.parentModuleInstance, key, rootProperty);
            }
            return dep;
        };
        Reactive.prototype.deepReactiveObject = function (value, rootProperty, propertyName) {
            var objectWithCustomPrototype = Object.create({
                rootProperty: rootProperty,
                propertyName: propertyName
            });
            // repopulate custom object with incoming values
            var keys = Object.keys(value);
            for (var i = 0; i < keys.length; i++) {
                var property = keys[i];
                objectWithCustomPrototype[property] = value[property];
            }
            this.allowPrivateWrite = true;
            var obj = this.reactiveObject(objectWithCustomPrototype, rootProperty);
            this.allowPrivateWrite = false;
            return obj;
        };
        Reactive.prototype.reactiveArray = function (array, key) {
            var self = this;
            var reactiveArray = array.slice();
            var _loop_1 = function (i) {
                var func = arrayFunctions[i];
                var original = Array.prototype[func];
                Object.defineProperty(reactiveArray, func, {
                    value: function () {
                        var result = original.apply(this, arguments);
                        if (self.global.initComplete)
                            // self.dispatch('mutation', {
                            //   collection: self.collection.name,
                            //   key,
                            //   value: result
                            // });
                            return result;
                    }
                });
            };
            for (var i = 0; i < arrayFunctions.length; i++) {
                _loop_1(i);
            }
            return reactiveArray;
        };
        Reactive.prototype.privateWrite = function (property, value) {
            this.allowPrivateWrite = true;
            this.object[property] = value;
            this.allowPrivateWrite = false;
        };
        // sneaky blocked the getter, sneaky.
        Reactive.prototype.privateGet = function (property) {
            this.sneaky = true;
            var data = this.object[property];
            this.sneaky = false;
            return data;
        };
        Reactive.prototype.exists = function (property) {
            this.sneaky = true;
            var bool = !!this.object.hasOwnProperty(property);
            this.sneaky = false;
            return bool;
        };
        Reactive.prototype.getKeys = function () {
            this.sneaky = true;
            var keys = Object.keys(this.object);
            this.sneaky = false;
            return keys;
        };
        Reactive.prototype.createReactiveAlias = function (destObj, propertyName) {
            if (destObj.hasOwnProperty(propertyName))
                return destObj;
            var self = this;
            Object.defineProperty(destObj, propertyName, {
                get: function pulseGetterAlias() {
                    return self.object[propertyName];
                },
                set: function pulseSetterAlias(newValue) {
                    self.object[propertyName] = newValue;
                    return;
                }
            });
            return destObj;
        };
        return Reactive;
    }());
    //# sourceMappingURL=reactive.js.map

    var Action = /** @class */ (function () {
        function Action(parentModuleInstance, global, action, actionName) {
            this.parentModuleInstance = parentModuleInstance;
            this.global = global;
            this.action = action;
            this.actionName = actionName;
            this.executing = false;
            this.changes = new Set();
            this.prepare(action, global, this.global.contextRef.undo);
        }
        Action.prototype.prepare = function (action, global, undo) {
            var _this = this;
            this.exec = function () {
                var _this_1 = this;
                var context = global.getContext(_this.parentModuleInstance);
                // wrap undo function with action context
                context.undo = function (error) { return undo(_this_1, error); };
                _this.declareActionRunning();
                // run action with context
                var result = action.apply(null, [context].concat(Array.prototype.slice.call(arguments)));
                _this.declareActionFinishedRunning();
                return result;
            };
        };
        //
        Action.prototype.declareActionRunning = function () {
            // empty actions previous cached changes
            this.changes.clear();
            this.executing = true;
            // allow runtime to track nested action
            this.global.runtime.runningActions.push(this);
            this.global.runtime.runningAction = this;
        };
        Action.prototype.declareActionFinishedRunning = function () {
            var runtime = this.global.runtime;
            this.executing = false;
            this.changes.clear();
            runtime.runningActions.pop();
            // restore previous running action
            var previousAction = runtime.runningActions[runtime.runningActions.length - 1];
            if (previousAction)
                runtime.runningAction = previousAction;
        };
        Action.prototype.debounce = function (stealthMom, amount) {
            return __awaiter(this, void 0, void 0, function () {
                var _this_1 = this;
                return __generator(this, function (_a) {
                    // already interval running, cancel
                    if (this.debouncing)
                        clearInterval(this.debouncing);
                    // set countdown to original amount
                    this.ms = amount;
                    return [2 /*return*/, new Promise(function (resolve) {
                            // set debouncing to current interval
                            _this_1.debouncing = setInterval(function () {
                                // if this interval makes it to zero
                                if (_this_1.ms == 0) {
                                    clearInterval(_this_1.debouncing);
                                    _this_1.debouncing = false;
                                    return resolve(stealthMom());
                                }
                                --_this_1.ms;
                                // ensure this interval runs every millisecond
                            }, 1);
                        })];
                });
            });
        };
        Action.prototype.softDebounce = function (callback, amount) {
            return __awaiter(this, void 0, void 0, function () {
                var _this_1 = this;
                return __generator(this, function (_a) {
                    this.ms = amount;
                    this.debounceCallback = callback;
                    if (this.debouncing)
                        return [2 /*return*/];
                    this.debouncing = setInterval(function () {
                        if (_this_1.ms == 0) {
                            clearInterval(_this_1.debouncing);
                            _this_1.debouncing = false;
                            _this_1.debounceCallback();
                        }
                        --_this_1.ms;
                    }, 1);
                    return [2 /*return*/];
                });
            });
        };
        return Action;
    }());
    //# sourceMappingURL=action.js.map

    // modules have a contained reactivity system which is the base
    // of collections, services and
    var Module = /** @class */ (function () {
        function Module(name, global, root) {
            var _this = this;
            this.name = name;
            this.global = global;
            this.root = root;
            this.keys = {};
            this.methods = {};
            this.local = {};
            this.config = {}; //rename
            this.actions = {};
            this.computed = {};
            this.watchers = {};
            this.externalWatchers = {};
            this.persist = [];
            this.model = {};
            this.throttles = [];
            // define aliases
            this.config = root.config;
            // create this.root
            root = this.prepareRoot(root);
            // Prepare methods
            collectionFunctions.map(function (func) { return _this[func] && (_this.methods[func] = _this[func].bind(_this)); });
            var publicObject = this.preparePublicNamespace(root);
            // create public object
            this.keys.data = Object.keys(root.data || {});
            this.public = new Reactive(this, publicObject, this.keys.data);
            if (root.staticData) {
                this.keys.staticData = Object.keys(root.staticData);
                for (var property in root.staticData)
                    if (root.staticData.hasOwnProperty(property))
                        this.public.privateWrite(property, root.staticData[property]);
            }
            // init module features
            this.initActions(root.actions);
            this.initWatchers(root.watch);
            this.initComputed(root.computed);
            if (this.global.request || root.request)
                this.initRoutes(root.routes);
            // load persisted data from storage
            this.initPersist(root.persist);
            this.prepareLocalContext();
            // init finished
            if (root.onReady)
                this.onReady = root.onReady;
        }
        // this function is where any transforms to the root object
        // should be done, before namspace is initilized
        Module.prototype.prepareRoot = function (root) {
            root.computed = __assign({}, root.computed, root.filters); // legacy support
            this.root = root;
            return root;
        };
        Module.prototype.preparePublicNamespace = function (root) {
            var publicNamespace = {};
            // insert static properties
            var types = ['routes', 'indexes', 'local'];
            types.forEach(function (type) { return root[type] && (publicNamespace[type] = __assign({}, root[type])); });
            var namespaceWithMethods = Object.assign.apply(Object, [Object.create(this.methods),
                publicNamespace].concat(root.data, root.computed
            // ...root.actions
            ));
            return namespaceWithMethods;
        };
        Module.prototype.initRoutes = function (routes) {
            var _this = this;
            if (routes === void 0) { routes = {}; }
            this.keys.routes = Object.keys(routes);
            var routeWrapped = function (routeName) {
                var self = _this;
                return function () {
                    var requestObject = Object.assign({}, self.global.request);
                    requestObject.context = self.global.contextRef;
                    return routes[routeName].apply(null, [requestObject].concat(Array.prototype.slice.call(arguments)));
                };
            };
            for (var routeName in routes) {
                this.public.object.routes[routeName] = routeWrapped(routeName);
            }
        };
        Module.prototype.initActions = function (actions) {
            if (actions === void 0) { actions = {}; }
            this.keys.actions = Object.keys(actions);
            for (var actionName in actions) {
                this.actions[actionName] = new Action(this, this.global, actions[actionName], actionName);
                this.public.privateWrite(actionName, this.actions[actionName].exec);
            }
        };
        Module.prototype.initWatchers = function (watchers) {
            var _this = this;
            if (watchers === void 0) { watchers = {}; }
            this.keys.watchers = Object.keys(watchers);
            var _loop_1 = function (watcherName) {
                var watcher = watchers[watcherName];
                this_1.watchers[watcherName] = function () {
                    _this.global.runningWatcher = true;
                    var watcherOutput = watcher(_this.global.getContext(_this));
                    _this.global.runningWatcher = false;
                    return watcherOutput;
                };
            };
            var this_1 = this;
            for (var watcherName in watchers) {
                _loop_1(watcherName);
            }
        };
        Module.prototype.initComputed = function (computed) {
            if (computed === void 0) { computed = {}; }
            this.keys.computed = Object.keys(computed);
            for (var computedName in computed) {
                this.computed[computedName] = new Computed(this.global, this, computedName, computed[computedName]);
                this.public.privateWrite(computedName, this.global.config.computedDefault);
            }
        };
        Module.prototype.initPersist = function (persist) {
            var _this = this;
            if (persist === void 0) { persist = []; }
            if (!Array.isArray(persist))
                return;
            var _loop_2 = function (i) {
                var dataName = persist[i];
                // register this
                this_2.persist.push(dataName);
                if (this_2.global.storage.isPromise) {
                    this_2.global.storage.get(this_2.name, dataName).then(function (data) {
                        if (data === undefined || data === null)
                            return;
                        _this.global.ingest({
                            type: JobType.PUBLIC_DATA_MUTATION,
                            value: data,
                            property: dataName,
                            collection: _this,
                            dep: _this.getDep(dataName)
                        });
                    });
                }
                else {
                    var data = this_2.global.storage.get(this_2.name, dataName);
                    if (data === undefined || data === null)
                        return "continue";
                    this_2.public.privateWrite(dataName, data);
                }
            };
            var this_2 = this;
            for (var i = 0; i < persist.length; i++) {
                _loop_2(i);
            }
        };
        Module.prototype.runWatchers = function (property) {
            var watcher = this.watchers[property];
            if (watcher)
                watcher();
            var externalWatchers = this.externalWatchers[property];
            if (externalWatchers)
                externalWatchers.forEach(function (func) {
                    return typeof func === 'function' ? func() : false;
                });
        };
        // external functions
        Module.prototype.watch = function (property, callback) {
            if (!this.externalWatchers[property])
                this.externalWatchers[property] = [callback];
            else
                this.externalWatchers[property].push(callback);
        };
        Module.prototype.prepareLocalContext = function () {
            this.localContext = {
                data: {},
                computed: {}
            };
            var l = this.localContext;
            for (var type in l)
                for (var _i = 0, _a = this.keys[type]; _i < _a.length; _i++) {
                    var propertyName = _a[_i];
                    this.public.createReactiveAlias(l[type], propertyName);
                }
            if (this.keys.staticData)
                for (var _b = 0, _c = this.keys.staticData; _b < _c.length; _b++) {
                    var property = _c[_b];
                    l.data[property] = this.public.privateGet(property);
                }
            // insert static properties
            l.local = this.root.local;
            l.actions = createObj(this.keys.actions, this.public.object);
            l.routes = this.public.object.routes;
            if (this.keys.indexes) {
                l.indexes = this.indexes.public.object;
            }
            for (var method in this.methods)
                l[method] = this.methods[method];
        };
        Module.prototype.getSelfContext = function () {
            var globalContext = this.global.contextRef;
            var context = __assign({}, globalContext, this.localContext);
            return context;
        };
        Module.prototype.forceUpdate = function (property) {
            // ensure property exists on collection
            if (this.public.exists(property)) {
                // if property is directly mutable
                if (this.public.mutableProperties.includes(property)) {
                    this.global.ingest({
                        type: JobType.PUBLIC_DATA_MUTATION,
                        property: property,
                        collection: this,
                        value: this.public.privateGet(property),
                        dep: this.getDep(property)
                    });
                    // if property is a computed method
                }
                else if (this.computed[property]) {
                    this.global.ingest({
                        type: JobType.COMPUTED_REGEN,
                        property: property,
                        collection: this,
                        dep: this.getDep(property)
                    });
                }
                else if (this.indexes && this.indexes.exists(property)) {
                    this.global.ingest({
                        type: JobType.GROUP_UPDATE,
                        property: property,
                        collection: this,
                        dep: this.getDep(property, this.indexes.object)
                    });
                }
            }
        };
        Module.prototype.throttle = function (amount) {
            var _this = this;
            if (amount === void 0) { amount = 0; }
            // if action is currently running save in throttles
            if (this.global.runtime.runningAction) {
                this.throttles.push(this.global.runtime.runningAction);
            }
            // after the certain amount has possed remove the throttle via filter
            setTimeout(function () {
                _this.throttles = _this.throttles.filter(function (action) { return action !== _this.global.runtime.runningAction; });
            }, amount);
        };
        Module.prototype.debounce = function (func, amount, options) {
            return __awaiter(this, void 0, void 0, function () {
                var action;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            action = this.global.runtime.runningAction;
                            action.softDebounce(func, amount);
                            return [2 /*return*/];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Module.prototype.getDep = function (propertyName, reactiveObject) {
            var dep;
            this.global.touching = true;
            // if the property is on a deep reactive object or an index
            if (reactiveObject)
                reactiveObject[propertyName];
            // by default we assume the module's public object
            else
                this.public.object[propertyName];
            // extract the dep from global
            dep = this.global.touched;
            // reset state
            this.global.touching = false;
            this.global.touched = null;
            return dep;
        };
        Module.prototype.isComputedReady = function (computedName) {
            // if (this.computed.hasOwnProperty(computedName)) return true;
            return this.computed[computedName].hasRun;
        };
        return Module;
    }());
    //# sourceMappingURL=module.js.map

    //# sourceMappingURL=index.js.map

    var Reactive$1 = /** @class */ (function () {
        function Reactive(parentModuleInstance, object, mutableProperties, type) {
            if (object === void 0) { object = {}; }
            if (type === void 0) { type = 'public'; }
            this.parentModuleInstance = parentModuleInstance;
            this.mutableProperties = mutableProperties;
            this.type = type;
            this.ghosts = {}; // used by indexes only
            this.allowPrivateWrite = false;
            this.touching = false;
            this.tempDeps = {};
            this.global = parentModuleInstance.global;
            this.properties = Object.keys(object).concat(mutableProperties);
            this.object = this.reactiveObject(object);
        }
        Reactive.prototype.reactiveObject = function (object, rootProperty) {
            var objectKeys = rootProperty ? Object.keys(object) : this.properties;
            // Loop over all properties of the to-be reactive object
            for (var i = 0; i < objectKeys.length; i++) {
                var key = objectKeys[i];
                this.defineProperty(object, key, rootProperty);
            }
            return object;
        };
        Reactive.prototype.defineProperty = function (object, key, rootProperty) {
            var self = this;
            var value = object[key];
            if (object.rootProperty)
                rootProperty = object.rootProperty;
            // // If property is an array, make it reactive
            // if (Array.isArray(value)) {
            //   // value = this.reactiveArray(value, key);
            // }
            // rootProperty should be the current key if first deep object
            if (isWatchableObject(value) && !protectedNames.includes(key)) {
                value = this.deepReactiveObject(value, rootProperty || key, key);
            }
            // Create an instance of the dependency tracker
            var dep = this.createDep(key, rootProperty);
            Object.defineProperty(object, key, {
                get: function pulseGetter() {
                    if (self.sneaky || self.global.gettingContext)
                        return value;
                    if (self.global.touching) {
                        self.global.touched = dep;
                        return value;
                    }
                    dep.register();
                    return value;
                },
                set: function pulseSetter(newValue) {
                    // DEEP REACTIVE handler: "rootProperty" indicates if the object is "deep".
                    if (rootProperty && self.mutableProperties.includes(rootProperty)) {
                        // mutate locally
                        value = newValue;
                        // ingest mutation for deep property
                        self.global.runtime.ingest({
                            type: JobType.PUBLIC_DATA_MUTATION,
                            collection: self.parentModuleInstance,
                            property: rootProperty,
                            value: self.object[rootProperty],
                            dep: dep
                        });
                        // Regular mutations
                    }
                    else {
                        // if a protected name allow direct mutation
                        if (protectedNames.includes(key)) {
                            return (value = newValue);
                        }
                        // if backdoor open allow direct mutation
                        if (self.allowPrivateWrite) {
                            // dynamically convert new values to reactive if objects
                            // This is risky as fuck and kinda doesn't even work
                            if (isWatchableObject(newValue) && self.properties.includes(key)) {
                                newValue = self.deepReactiveObject(newValue, rootProperty || key, key);
                            }
                            return (value = newValue);
                        }
                        // if property is mutable dispatch update
                        if (self.properties.includes(key)) {
                            self.global.runtime.ingest({
                                type: JobType.PUBLIC_DATA_MUTATION,
                                collection: self.parentModuleInstance,
                                property: key,
                                value: newValue,
                                dep: dep
                            });
                            // we did not apply the mutation since runtime will privately
                            // write the result since we dispatched above
                        }
                    }
                }
            });
            return object;
        };
        Reactive.prototype.addProperty = function (key, value) {
            this.object[key] = value;
            this.defineProperty(this.object, key);
        };
        Reactive.prototype.tempDep = function (property) {
            var dep = this.createDep(property);
            this.tempDeps[property] = dep;
            return dep;
        };
        Reactive.prototype.cloneDep = function (dep) {
            dep = Object.assign(Object.create(Object.getPrototypeOf(dep)), dep);
            // delete this.tempDeps[dep.propertyName];
            return dep;
        };
        Reactive.prototype.createDep = function (key, rootProperty) {
            var dep;
            if (this.tempDeps.hasOwnProperty(key) && !rootProperty) {
                dep = this.cloneDep(this.tempDeps[key]);
            }
            else {
                dep = new Dep$1(this.global, this.type === 'indexes' ? 'index' : 'reactive', this.parentModuleInstance, key, rootProperty);
            }
            return dep;
        };
        Reactive.prototype.deepReactiveObject = function (value, rootProperty, propertyName) {
            var objectWithCustomPrototype = Object.create({
                rootProperty: rootProperty,
                propertyName: propertyName
            });
            // repopulate custom object with incoming values
            var keys = Object.keys(value);
            for (var i = 0; i < keys.length; i++) {
                var property = keys[i];
                objectWithCustomPrototype[property] = value[property];
            }
            this.allowPrivateWrite = true;
            var obj = this.reactiveObject(objectWithCustomPrototype, rootProperty);
            this.allowPrivateWrite = false;
            return obj;
        };
        Reactive.prototype.reactiveArray = function (array, key) {
            var self = this;
            var reactiveArray = array.slice();
            var _loop_1 = function (i) {
                var func = arrayFunctions[i];
                var original = Array.prototype[func];
                Object.defineProperty(reactiveArray, func, {
                    value: function () {
                        var result = original.apply(this, arguments);
                        if (self.global.initComplete)
                            // self.dispatch('mutation', {
                            //   collection: self.collection.name,
                            //   key,
                            //   value: result
                            // });
                            return result;
                    }
                });
            };
            for (var i = 0; i < arrayFunctions.length; i++) {
                _loop_1(i);
            }
            return reactiveArray;
        };
        Reactive.prototype.privateWrite = function (property, value) {
            this.allowPrivateWrite = true;
            this.object[property] = value;
            this.allowPrivateWrite = false;
        };
        // sneaky blocked the getter, sneaky.
        Reactive.prototype.privateGet = function (property) {
            this.sneaky = true;
            var data = this.object[property];
            this.sneaky = false;
            return data;
        };
        Reactive.prototype.exists = function (property) {
            this.sneaky = true;
            var bool = !!this.object.hasOwnProperty(property);
            this.sneaky = false;
            return bool;
        };
        Reactive.prototype.getKeys = function () {
            this.sneaky = true;
            var keys = Object.keys(this.object);
            this.sneaky = false;
            return keys;
        };
        Reactive.prototype.createReactiveAlias = function (destObj, propertyName) {
            if (destObj.hasOwnProperty(propertyName))
                return destObj;
            var self = this;
            Object.defineProperty(destObj, propertyName, {
                get: function pulseGetterAlias() {
                    return self.object[propertyName];
                },
                set: function pulseSetterAlias(newValue) {
                    self.object[propertyName] = newValue;
                    return;
                }
            });
            return destObj;
        };
        return Reactive;
    }());
    //# sourceMappingURL=Reactive.js.map

    var Collection = /** @class */ (function (_super) {
        __extends(Collection, _super);
        function Collection(name, global, root) {
            var _this = 
            // init module constructor
            _super.call(this, name, global, root) || this;
            _this.primaryKey = false;
            _this.internalData = {};
            _this.internaldataPropertiesUsingPopulate = [];
            _this.internalDataDeps = {}; // contains the deps for internal data
            _this.collectionSize = 0;
            //collection only preperation
            _this.initIndexes(root.groups);
            _this.initModel(root.model);
            return _this;
        }
        Collection.prototype.getDataDep = function (primaryKey) {
            return this.internalDataDeps[primaryKey] || false;
        };
        Collection.prototype.initIndexes = function (groups) {
            // FIXME: if you want indexes to be reactive Jamie, that empty array right there is your answer
            this.indexes = new Reactive$1(this, normalizeGroups(groups), [], 'indexes');
            this.public.privateWrite('indexes', this.indexes.object);
            for (var _i = 0, _a = this.indexes.properties; _i < _a.length; _i++) {
                var indexName = _a[_i];
                // init empty group
                this.public.addProperty(indexName, []);
            }
        };
        Collection.prototype.initModel = function (model) {
            var _this = this;
            if (model === void 0) { model = {}; }
            this.model = model;
            Object.keys(model).forEach(function (property) {
                Object.keys(model[property]).forEach(function (config) {
                    switch (config) {
                        case 'primaryKey':
                            _this.primaryKey = property;
                            break;
                        case 'populate':
                            _this.internaldataPropertiesUsingPopulate.push(property);
                            break;
                    }
                });
            });
        };
        Collection.prototype.getData = function (id) {
            if (!this.internalData.hasOwnProperty(id))
                return false;
            return __assign({}, this.internalData[id]);
        };
        Collection.prototype.buildGroupFromIndex = function (groupName) {
            var _this = this;
            var constructedArray = [];
            // get index directly
            var index = this.indexes.privateGet(groupName);
            if (!index)
                return [];
            var getData = function (id) {
                // copy data from internal database
                var data = _this.getData(id);
                // if none found skip
                if (!data)
                    return false;
                // inject dynamic data
                return _this.injectDynamicRelatedData(id, data);
            };
            // for every primaryKey in the index
            for (var i = 0; i < index.length; i++) {
                var data = getData(index[i]);
                if (!data)
                    continue;
                constructedArray.push(data);
            }
            // inject ghosts
            if (this.indexes.ghosts[groupName]) {
                var ghosts = this.indexes.ghosts[groupName];
                for (var i = 0; i < ghosts.length; i++) {
                    var _a = ghosts[i], index_1 = _a.index, primaryKey = _a.primaryKey;
                    var data = getData(primaryKey);
                    if (!data)
                        continue;
                    data.isGhost = true;
                    constructedArray.splice(index_1, 0, data);
                }
            }
            return constructedArray;
        };
        // rebuilding an entire group is expensive on resources, but is
        // not nessisary if only one piece of data has changed
        // this function will replace a single piece of data without rebuilding
        // the entire group
        Collection.prototype.softUpdateGroupData = function (primaryKey, groupName) {
            var index = this.indexes.privateGet(groupName);
            // find the data's position within index
            var position = index.indexOf(primaryKey);
            // if group is dynamic, just build the group from index.
            if (!this.public[groupName])
                return this.buildGroupFromIndex(groupName);
            // copy the current group output
            var currentGroup = [this.public[groupName]];
            // get data for primaryKey
            var data = __assign({}, this.internalData[primaryKey]);
            data = this.injectDynamicRelatedData(primaryKey, data);
            // replace at known position with updated data
            currentGroup[position] = data;
            return currentGroup;
        };
        // This should be called on every piece of data retrieved when building a group from an index
        Collection.prototype.injectDynamicRelatedData = function (primaryKey, data) {
            var _this = this;
            // for each populate function extracted from the model for this data
            this.internaldataPropertiesUsingPopulate.forEach(function (property) {
                // conditions to skip populate
                var dep = _this.getDataDep(primaryKey);
                var job = _this.global.runtime.runningJob;
                if (!dep || (job && job.config && job.config.important))
                    return;
                // get the current action index in runtime action stack
                // this is used to stop properties from getting tracked as dependencies in nested actions
                dep.currentActionIndex = _this.global.runtime.runningActions.length;
                _this.global.runningPopulate = dep;
                // run populate function passing in the context and the data
                var populated = _this.model[property].populate(_this.global.contextRef, data);
                dep.currentActionIndex = false;
                _this.global.runningPopulate = false;
                // inject result to data
                data[property] = populated;
            });
            return data;
        };
        Collection.prototype.createGroups = function (group) {
            if (group === undefined)
                group = [];
            else if (!Array.isArray(group))
                group = [group];
            for (var i = 0; i < group.length; i++) {
                var groupName = group[i];
                if (!this.indexes.exists(groupName)) {
                    this.indexes.addProperty(groupName, []);
                    // this.indexes.privateWrite(groupName, []);
                }
            }
            return group;
        };
        Collection.prototype.getPreviousIndexValues = function (groups) {
            var returnData = {};
            for (var i = 0; i < groups; i++) {
                var groupName = groups[i];
                returnData[groupName] = this.indexes.privateGet(groupName);
            }
            return returnData;
        };
        Collection.prototype.findPrimaryKey = function (dataItem) {
            if (dataItem.hasOwnProperty('id'))
                this.primaryKey = 'id';
            else if (dataItem.hasOwnProperty('_id'))
                this.primaryKey = '_id';
            else if (dataItem.hasOwnProperty('key'))
                this.primaryKey = 'key';
            if (this.primaryKey)
                return true;
            else
                return assert(function (warn) { return warn.NO_PRIMARY_KEY; });
        };
        // if a computed function evaluates and creates a relation to internal data
        // that does not exist yet, we create the dep class and save it in advance
        // so that if the data ever arrives, it will reactively dependent update accordingly
        Collection.prototype.depForInternalData = function (primaryKey) {
            var dep;
            if (!this.internalDataDeps[primaryKey]) {
                dep = new Dep$1(this.global, 'internal', this, primaryKey);
                this.internalDataDeps[primaryKey] = dep;
            }
            else {
                dep = this.internalDataDeps[primaryKey];
            }
            return dep;
        };
        // search the collection for the appropriate dep for a given group
        // consider relacting this with a more absolute
        // ^^ hi, its jamie from months later, don't think theres any other way to do this boss
        // maybe be more explicit with what are groups and what aren't
        // but i also don't think its an issue, we'll see.
        // a potential issue that could arise is a dynamic index with the same name as some data
        // will return the wrong dep class
        Collection.prototype.depForGroup = function (groupName) {
            var dep;
            // no group is found publically, use index instead
            if (this.public.exists(groupName)) {
                dep = this.getDep(groupName);
            }
            else if (this.indexes.exists(groupName)) {
                dep = this.getDep(groupName, this.indexes.object);
            }
            else {
                // create a temp dep for dynamic indexes
                dep = this.indexes.tempDep(groupName);
            }
            return dep;
        };
        Collection.prototype.replaceIndex = function (indexName, newIndex) {
            if (!Array.isArray(newIndex) || typeof indexName !== 'string')
                return assert(function (warn) { return warn.INVALID_PARAMETER; });
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this,
                property: indexName,
                value: newIndex
            });
        };
        // METHODS
        Collection.prototype.collect = function (data, group, config) {
            var _this = this;
            config = defineConfig(config, {
                append: true
            });
            this.global.collecting = true;
            // normalise data
            if (!Array.isArray(data))
                data = [data];
            // if groups don't already exist, create them dynamically
            var groups = this.createGroups(group);
            // groups now contains just the groups directly modified by this collect
            // preserve index previous values
            var previousIndexValues = this.getPreviousIndexValues(groups);
            var indexesToRegenOnceComplete = new Set();
            // process data items
            for (var i = 0; i < data.length; i++) {
                var dataItem = data[i];
                if (dataItem === null)
                    continue;
                // process data item returns "success" as a boolean and affectedIndexes as an array
                var processDataItem = this.processDataItem(dataItem, groups, config);
                if (!processDataItem)
                    continue;
                if (processDataItem.success)
                    this.collectionSize++;
                // ensure indexes modified by this data item are waiting to be ingested for regen
                processDataItem.affectedIndexes.forEach(function (index) {
                    return indexesToRegenOnceComplete.add(index);
                });
            }
            indexesToRegenOnceComplete.forEach(function (indexName) {
                _this.global.ingest({
                    type: JobType.INDEX_UPDATE,
                    collection: _this,
                    property: indexName,
                    value: _this.indexes.privateGet(indexName),
                    previousValue: previousIndexValues[indexName],
                    dep: _this.getDep(indexName)
                });
            });
            this.global.collecting = false;
        };
        Collection.prototype.processDataItem = function (dataItem, groups, config) {
            if (groups === void 0) { groups = []; }
            if (!this.primaryKey)
                this.findPrimaryKey(dataItem);
            if (!this.primaryKey)
                return false;
            var key = dataItem[this.primaryKey];
            // find affected indexes
            var affectedIndexes = groups.slice();
            // searchIndexesForPrimaryKey returns an array of indexes that include that primaryKey
            // for each index found, if it is not already known, add to affected indexes
            this.searchIndexesForPrimaryKey(key).map(function (index) { return !affectedIndexes.includes(index) && affectedIndexes.push(index); });
            // validate against model
            // create the dep class
            if (!this.internalDataDeps[key])
                this.internalDataDeps[key] = new Dep$1(this.global, 'internal', this, key);
            // ingest the data
            this.global.ingest({
                type: JobType.INTERNAL_DATA_MUTATION,
                collection: this,
                property: key,
                value: dataItem,
                dep: this.internalDataDeps[key]
            });
            // add the data to group indexes
            for (var i = 0; i < groups.length; i++) {
                var groupName = groups[i];
                var index = this.indexes.privateGet(groupName);
                // remove key if already present in index
                index = index.filter(function (k) { return k != key; });
                if (config.append)
                    index.push(key);
                else
                    index.unshift(key);
                // write index
                this.indexes.privateWrite(groupName, index);
            }
            return { success: true, affectedIndexes: affectedIndexes };
        };
        Collection.prototype.searchIndexesForPrimaryKey = function (primaryKey) {
            // get a fresh copy of the keys to include dynamic indexes
            var keys = this.indexes.getKeys();
            var foundIndexes = [];
            // for every index
            for (var i = 0; i < keys.length; i++) {
                var indexName = keys[i];
                // if the index includes the primaryKey
                if (this.indexes.privateGet(indexName).includes(primaryKey))
                    foundIndexes.push(indexName);
            }
            return foundIndexes;
        };
        // return a piece of intenral data from the collection
        // can create dynamic relationships when used in certain circumstances
        Collection.prototype.findById = function (id) {
            var internalDep = this.depForInternalData(id);
            // if used in computed function, create a dynamic relation
            if (this.global.runningComputed) {
                var computed = this.global.runningComputed;
                this.global.relations.relate(computed, internalDep);
            }
            // if used in populate() function, create a dynamic relation
            if (this.global.runningPopulate) {
                var populate = this.global.runningPopulate;
                this.global.relations.relate(populate, internalDep);
            }
            return this.internalData[id];
        };
        // return a group of data from a collection
        // can create dynamic relationships when used in certain circumstances
        Collection.prototype.getGroup = function (property) {
            var groupDep = this.depForGroup(property);
            // if used in computed function, create a dynamic relation
            if (this.global.runningComputed) {
                var computed = this.global.runningComputed;
                this.global.relations.relate(computed, groupDep);
            }
            // if used in populate() function, create a dynamic relation
            if (this.global.runningPopulate) {
                var dataDep = this.global.runningPopulate;
                this.global.relations.relate(dataDep, groupDep);
            }
            // get group is not cached, so generate a fresh group from the index
            return this.buildGroupFromIndex(property) || [];
        };
        // FIXME: action functions
        Collection.prototype.undo = function (action) {
            var _this = this;
            // runtime stores changes in action
            action.changes.forEach(function (job) {
                if (job.hasOwnProperty('previousValue')) {
                    var currentValue = job.value;
                    job.value = job.previousValue;
                    job.previousValue = currentValue;
                    _this.global.ingest(job);
                }
            });
        };
        // group functions
        Collection.prototype.move = function (ids, sourceIndexName, destIndexName, config) {
            config = defineConfig(config, {
                method: 'push',
                ghost: false
            });
            // validation
            if (!this.indexes.exists(sourceIndexName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (destIndexName && !this.indexes.exists(destIndexName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (!Array.isArray(ids))
                ids = [ids];
            var sourceIndex = this.indexes.privateGet(sourceIndexName);
            var _loop_1 = function (i) {
                // preserve ghost index
                if (config.ghost)
                    this_1.haunt(sourceIndexName, sourceIndex, ids[i]);
                // remove the id from index
                sourceIndex = sourceIndex.filter(function (id) { return id !== ids[i]; });
            };
            var this_1 = this;
            for (var i = 0; i < ids.length; i++) {
                _loop_1(i);
            }
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this,
                property: sourceIndexName,
                value: sourceIndex
            });
            if (destIndexName) {
                var destIndex = this.indexes.privateGet(destIndexName);
                for (var i = 0; i < ids.length; i++) {
                    // destIndex = destIndex.filter(k => k != ids[i]);
                    if (destIndex.includes(ids[i]))
                        continue;
                    // push or unshift id into current index
                    destIndex[config.method](ids[i]);
                }
                this.global.ingest({
                    type: JobType.INDEX_UPDATE,
                    collection: this,
                    property: destIndexName,
                    value: destIndex
                });
            }
        };
        Collection.prototype.put = function (ids, destIndexName, config) {
            config = defineConfig(config, {
                method: 'push'
            });
            // validation
            if (!this.indexes.exists(destIndexName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (!Array.isArray(ids))
                ids = [ids];
            // get current index
            var destIndex = this.indexes.privateGet(destIndexName);
            // loop over every id user is trying to add into current index
            for (var i = 0; i < ids.length; i++) {
                // destIndex = destIndex.filter(k => k != ids[i]);
                if (destIndex.includes(ids[i]))
                    continue;
                // push or unshift id into current index
                destIndex[config.method](ids[i]);
            }
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this,
                property: destIndexName,
                value: destIndex
            });
        };
        Collection.prototype.newGroup = function (groupName, indexValue) {
            if (this.indexes.object.hasOwnProperty(groupName))
                return assert(function (warn) { return warn.GROUP_ALREADY_EXISTS; });
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this,
                property: groupName,
                value: indexValue
            });
        };
        Collection.prototype.deleteGroup = function (groupName) {
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this,
                property: groupName,
                value: []
            });
        };
        Collection.prototype.removeFromGroup = function (groupName, keysToRemove, config) {
            var _this = this;
            config = defineConfig(config, {
                method: 'push',
                ghost: false
            });
            if (!this.indexes.exists(groupName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (!Array.isArray(keysToRemove))
                keysToRemove = [keysToRemove];
            var index = this.indexes.privateGet(groupName);
            if (config.ghost)
                keysToRemove.forEach(function (key) { return _this.haunt(groupName, index, key); });
            var newIndex = index.filter(function (id) { return !keysToRemove.includes(id); });
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this,
                property: groupName,
                value: newIndex
            });
        };
        // internal data functions
        Collection.prototype.update = function (primaryKey, newObject, options) {
            if (newObject === void 0) { newObject = {}; }
            options = defineConfig(options, {
                important: false
            });
            // if the primary key has changed, we should update it internally for this data
            var updateDataKey = false;
            if (!this.internalData.hasOwnProperty(primaryKey))
                return assert(function (warn) { return warn.INTERNAL_DATA_NOT_FOUND; });
            var newObjectKeys = Object.keys(newObject);
            var currentData = Object.assign({}, this.internalData[primaryKey]);
            for (var i = 0; i < newObjectKeys.length; i++) {
                var key = newObjectKeys[i];
                if (key === this.primaryKey)
                    updateDataKey = true;
                currentData[key] = newObject[key];
            }
            this.global.ingest({
                type: JobType.INTERNAL_DATA_MUTATION,
                collection: this,
                property: primaryKey,
                value: currentData,
                config: options
            });
            if (updateDataKey)
                this.updateDataKey(newObject[primaryKey], // old primary key
                currentData[this.primaryKey] // new primary key
                );
        };
        Collection.prototype.increment = function (primaryKey, property, amount, decrement) {
            if (!this.internalData.hasOwnProperty(primaryKey))
                return assert(function (warn) { return warn.INTERNAL_DATA_NOT_FOUND; });
            var currentData = Object.assign({}, this.internalData[primaryKey]);
            if (!validateNumber(amount, currentData[property]))
                return assert(function (warn) { return warn.PROPERTY_NOT_A_NUMBER; });
            if (decrement)
                currentData[property] -= amount;
            else
                currentData[property] += amount;
            this.global.ingest({
                type: JobType.INTERNAL_DATA_MUTATION,
                collection: this,
                property: primaryKey,
                value: currentData
            });
        };
        Collection.prototype.decrement = function (primaryKey, property, amount) {
            this.increment(primaryKey, property, amount, true);
        };
        Collection.prototype.delete = function (primaryKeys) {
            if (!Array.isArray(primaryKeys))
                primaryKeys = [primaryKeys];
            for (var i = 0; i < primaryKeys.length; i++) {
                var primaryKey = primaryKeys[i];
                this.global.ingest({
                    type: JobType.DELETE_INTERNAL_DATA,
                    collection: this,
                    property: primaryKey
                });
            }
        };
        Collection.prototype.updateDataKey = function (oldKey, newKey) {
            // create copy of data & data dep
            var dataCopy = __assign({}, this.internalData[oldKey]), depCopy = __assign({}, this.internalDataDeps[oldKey]);
            // delete old refrences
            delete this.internalData[oldKey];
            delete this.internalDataDeps[oldKey];
            // apply the data and dependency in storage
            this.internalData[newKey] = dataCopy;
            this.internalDataDeps[newKey] = depCopy;
        };
        // TODO: make cleanup unsubscribe func, possible memory leak, you'll need to track the component
        Collection.prototype.watchData = function (primaryKey, callback) {
            var dep = this.internalDataDeps[primaryKey];
            if (!dep)
                return;
            dep.subscribersToInternalDataAsCallbacks.push(callback);
        };
        // rebuild issues a group regeneration for an index, and destorys all ghosts. It is effectivly the 5th ghost buster.
        Collection.prototype.rebuild = function (indexName) {
            if (!this.indexes.exists(indexName))
                return;
            delete this.indexes.ghosts[indexName];
            this.global.ingest({
                type: JobType.GROUP_UPDATE,
                collection: this,
                property: indexName
            });
        };
        Collection.prototype.haunt = function (sourceIndexName, sourceIndex, id) {
            if (!this.indexes.ghosts[sourceIndexName])
                this.indexes.ghosts[sourceIndexName] = [];
            var removedIndex = sourceIndex.indexOf(id);
            this.indexes.ghosts[sourceIndexName].push({
                index: removedIndex,
                primaryKey: id
            });
        };
        Collection.prototype.cleanse = function () {
            var _this = this;
            // loop over ghosts to get index names
            var groupsToRegen = Object.keys(this.indexes.ghosts);
            this.indexes.ghosts = {};
            groupsToRegen.forEach(function (groupName) {
                _this.global.runtime.ingest({
                    type: JobType.GROUP_UPDATE,
                    collection: _this,
                    property: groupName
                });
            });
        };
        // remove all dynamic indexes, empty all indexes, delete all internal data
        Collection.prototype.purge = function () { };
        // deprecate
        // added removeFromGroup to be more specific, params got switched around, keeping this for backwards compatibility
        Collection.prototype.remove = function (itemsToRemove, groupName) {
            return this.removeFromGroup(groupName, itemsToRemove);
        };
        return Collection;
    }(Module));
    //# sourceMappingURL=collection.js.map

    // This file handles external components subscribing to pulse.
    var ComponentContainer = /** @class */ (function () {
        function ComponentContainer(instance, config) {
            this.instance = instance;
            this.config = config;
            this.uuid = genId();
            instance.__pulseUniqueIdentifier = this.uuid;
            if (config.waitForMount)
                this.ready = false;
        }
        return ComponentContainer;
    }());
    var SubController = /** @class */ (function () {
        function SubController(getContextRef) {
            this.getContextRef = getContextRef;
            this.subscribingComponentKey = 0;
            this.trackingComponent = false;
            // public unsubscribingComponent: boolean = false;
            this.skimmingDeepReactive = false;
            this.lastAccessedDep = null;
            this.componentStore = {};
        }
        SubController.prototype.registerComponent = function (instance, config) {
            config = defineConfig(config, {
                waitForMount: false,
                blindSubscribe: false
            });
            var uuid = instance.__pulseUniqueIdentifier;
            if (!uuid) {
                var componentContainer = new ComponentContainer(instance, config);
                this.componentStore[componentContainer.uuid] = componentContainer;
            }
            else {
                this.mount(instance);
            }
            return uuid;
        };
        SubController.prototype.get = function (id) {
            return this.componentStore[id] || false;
        };
        SubController.prototype.mount = function (instance) {
            var component = this.componentStore[instance.__pulseUniqueIdentifier];
            if (component) {
                component.instance = instance;
                component.ready = true;
            }
        };
        SubController.prototype.unmount = function (instance) {
            var uuid = instance.__pulseUniqueIdentifier;
            if (!uuid)
                return;
            // delete reference to this component from store
            delete this.componentStore[instance.__pulseUniqueIdentifier];
        };
        return SubController;
    }());
    //# sourceMappingURL=subController.js.map

    var Storage = /** @class */ (function () {
        function Storage(storageMethods) {
            if (storageMethods === void 0) { storageMethods = {}; }
            this.storageMethods = storageMethods;
            this.isPromise = false;
            this.storageReady = false;
            this.storageType = 'localStorage';
            if (storageMethods.async)
                this.isPromise = true;
            // assume if user provided get, set or remove methods that the storage type is custom
            if (storageMethods.get || storageMethods.set || storageMethods.remove) {
                this.storageType = 'custom';
            }
            if (this.localStorageAvailable() && this.storageType === 'localStorage') {
                this.storageReady = true;
                storageMethods.get = localStorage.getItem.bind(localStorage);
                storageMethods.set = localStorage.setItem.bind(localStorage);
                storageMethods.remove = localStorage.removeItem.bind(localStorage);
            }
            else {
                this.storageType = 'custom';
                if (this.check(storageMethods.get) &&
                    this.check(storageMethods.set) &&
                    this.check(storageMethods.remove)) {
                    this.storageReady = true;
                }
                else {
                    this.storageReady = false;
                    // bad
                }
            }
        }
        Storage.prototype.get = function (moduleName, key) {
            var _this = this;
            if (!this.storageReady)
                return;
            if (this.isPromise) {
                return new Promise(function (resolve, reject) {
                    _this.storageMethods
                        .get(_this.getKey(moduleName, key))
                        .then(function (res) {
                        // if result is not JSON for some reason, return it.
                        if (typeof res !== 'string')
                            return resolve(res);
                        resolve(JSON.parse(res));
                    })
                        .catch(reject);
                });
            }
            else {
                return JSON.parse(this.storageMethods.get(this.getKey(moduleName, key)));
            }
        };
        Storage.prototype.set = function (moduleName, key, value) {
            if (!this.storageReady)
                return;
            this.storageMethods.set(this.getKey(moduleName, key), JSON.stringify(value));
        };
        Storage.prototype.remove = function (moduleName, key) {
            if (!this.storageReady)
                return;
            this.storageMethods.remove(this.getKey(moduleName, key));
        };
        Storage.prototype.getKey = function (moduleName, key) {
            return "_" + moduleName + "_" + key;
        };
        Storage.prototype.check = function (func) {
            return typeof func === 'function';
        };
        Storage.prototype.localStorageAvailable = function () {
            try {
                localStorage.setItem('_', '_');
                localStorage.removeItem('_');
                return true;
            }
            catch (e) {
                return false;
            }
        };
        return Storage;
    }());
    //# sourceMappingURL=storage.js.map

    var Request = /** @class */ (function (_super) {
        __extends(Request, _super);
        function Request(global, requestConfig) {
            var _this = this;
            // Before we invoke the parent class, we define some defaults
            var groups = [];
            var persist = ['baseURL'];
            var data = {
                baseURL: requestConfig.baseURL || '',
                mode: 'cors',
                credentials: 'same-origin',
                headers: {
                    Accept: 'application/json'
                }
            };
            if (requestConfig.headers)
                Object.keys(requestConfig.headers).forEach(function (header) {
                    data.headers[header] = requestConfig.headers[header];
                });
            if (requestConfig.credentials)
                data.credentials = requestConfig.credentials;
            if (requestConfig.mode)
                data.mode = requestConfig.mode;
            _this = _super.call(this, 'request', global, { groups: groups, data: data, persist: persist }) || this;
            _this.requestIntercept = requestConfig.requestIntercept;
            _this.responseIntercept = requestConfig.responseIntercept;
            _this.timeout = requestConfig.timeout;
            _this.saveHistory =
                typeof requestConfig.saveHistory === 'undefined' ? true : false;
            _this.global.request = {
                get: _this.get.bind(_this),
                post: _this.post.bind(_this),
                put: _this._put.bind(_this),
                patch: _this.patch.bind(_this),
                delete: _this.delete.bind(_this),
                queryify: _this.queryify.bind(_this)
            };
            return _this;
        }
        Request.prototype.get = function (url, headers) {
            return this.send(url, 'get', {}, headers);
        };
        Request.prototype.post = function (url, body, headers) {
            return this.send(url, 'post', body, headers);
        };
        Request.prototype._put = function (url, body, headers) {
            return this.send(url, 'put', body, headers);
        };
        Request.prototype.patch = function (url, body, headers) {
            return this.send(url, 'patch', body, headers);
        };
        Request.prototype.delete = function (url, body, headers) {
            return this.send(url, 'delete', body, headers);
        };
        Request.prototype.send = function (url, method, body, headers) {
            if (body === void 0) { body = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var requestHeaders, fullURL, options, response, contentType, final, keys, i, property;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            requestHeaders = Object.assign({}, this.public.object.headers);
                            if (headers)
                                Object.keys(headers).forEach(function (header) {
                                    requestHeaders[header] = headers[header];
                                });
                            // If method is not get set application type
                            if (method !== 'get' && requestHeaders['Content-Type'] === undefined)
                                requestHeaders['Content-Type'] = 'application/json';
                            if (url.startsWith('http'))
                                fullURL = url;
                            else
                                fullURL = this.public.object.baseURL + "/" + url;
                            // Stringify body
                            body = JSON.stringify(body);
                            // Build options
                            this.options = {};
                            this.options.credentials = this.public.object.credentials;
                            this.options.mode = this.public.object.mode;
                            options = Object.assign({
                                headers: requestHeaders,
                                method: method.toUpperCase(),
                                body: method === 'get' ? null : body
                            }, this.options);
                            if (this.requestIntercept)
                                this.requestIntercept(this.global.getContext(this), options);
                            if (!this.timeout) return [3 /*break*/, 2];
                            return [4 /*yield*/, Promise.race([
                                    fetch(fullURL, options),
                                    new Promise(function (resolve, reject) {
                                        return setTimeout(function () { return reject('timeout'); }, _this.timeout);
                                    })
                                ])];
                        case 1:
                            response = _a.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, fetch(fullURL, options)];
                        case 3:
                            response = _a.sent();
                            _a.label = 4;
                        case 4:
                            contentType = response.headers.get('content-type');
                            if (!(contentType && contentType.indexOf('application/json') !== -1)) return [3 /*break*/, 6];
                            return [4 /*yield*/, response.json()];
                        case 5:
                            body = _a.sent();
                            return [3 /*break*/, 8];
                        case 6: return [4 /*yield*/, response.text()];
                        case 7:
                            body = _a.sent();
                            _a.label = 8;
                        case 8:
                            // history
                            if (!this.saveHistory)
                                this.collect({
                                    id: Date.now(),
                                    status: response.status,
                                    timestamp: new Date(),
                                    response: body
                                });
                            // If reponse body is an object, create a custom object with response function in prototype, so headers and the full response data can be accessed outside of this class
                            if (!Array.isArray(body) && typeof body === 'object') {
                                final = Object.create({
                                    response: function () {
                                        return response;
                                    }
                                });
                                keys = Object.keys(body);
                                for (i = 0; i < keys.length; i++) {
                                    property = keys[i];
                                    final[property] = body[property];
                                }
                                // if the body is not an object, we can not inject a prototype, so just return the rew body
                            }
                            else {
                                final = body;
                            }
                            // intercept response
                            if (this.responseIntercept) {
                                response.data = body;
                                this.responseIntercept(this.global.getContext(this), response);
                            }
                            // reject if bad response status
                            if (response.ok || response.redirected)
                                return [2 /*return*/, final];
                            // resolve response
                            throw final;
                    }
                });
            });
        };
        // Adapted from: https://github.com/Gozala/querystring/blob/master/encode.js
        Request.prototype.queryify = function (obj) {
            var stringifyPrimitive = function (value) {
                switch (typeof value) {
                    case 'string':
                        return value;
                    case 'boolean':
                        return value ? 'true' : 'false';
                    case 'number':
                        return isFinite(value) ? value : '';
                    default:
                        return '';
                }
            };
            // validate input
            if (typeof obj != 'object')
                return;
            return Object.keys(obj)
                .map(function (key) {
                var encodedKey = encodeURIComponent(stringifyPrimitive(key)) + '=';
                // if value is an array, encode with same key as parent
                if (Array.isArray(obj[key]))
                    return obj[key]
                        .map(function (value) {
                        return encodedKey + encodeURIComponent(stringifyPrimitive(value));
                    })
                        .join('&');
                // join encoded key with value
                return encodedKey + encodeURIComponent(stringifyPrimitive(obj[key]));
            })
                .join('&');
        };
        return Request;
    }(Module));
    //# sourceMappingURL=request.js.map

    function ReactWrapper(ReactComponent) {
        var pulse = globalThis.__pulse;
        if (!pulse)
            console.error("Pulse X React: Pulse instance inaccessible, it is likely you're using \"Pulse.React()\" before \"new Pulse()\"");
        var global = pulse._private.global;
        var React = global.config.frameworkConstructor;
        return /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1(props) {
                var _this = _super.call(this, props) || this;
                _this.props = props;
                // subscribe component to Pulse
                global.subs.registerComponent(_this, {
                    waitForMount: global.config.waitForMount,
                    blindSubscribe: true
                });
                return _this;
            }
            class_1.prototype.componentDidMount = function () {
                global.subs.trackingComponent = false;
                if (global.config.waitForMount)
                    pulse.mount(this);
            };
            class_1.prototype.componentWillUnmount = function () {
                if (global.config.autoUnmount)
                    pulse.unmount(this);
            };
            class_1.prototype.render = function () {
                global.subs.trackingComponent = global.subs.get(this.__pulseUniqueIdentifier);
                if (!global.subs.trackingComponent)
                    console.error('Pulse x React: React component not found!');
                var component = React.createElement(ReactComponent, this.props);
                return component;
            };
            return class_1;
        }(React.Component));
    }
    function useFramework(ReactConstructor) {
        // set framework here
    }
    //# sourceMappingURL=ReactWithPulse.js.map

    var Pulse = /** @class */ (function () {
        function Pulse(root) {
            var _this = this;
            if (root === void 0) { root = {}; }
            // Private object contains all internal Pulse data
            this._private = {
                modules: {},
                collections: {},
                helpers: {},
                services: {},
                keys: {
                    modules: ['base'],
                    collections: [],
                    services: []
                },
                events: {},
                // global is passed in to all classes, must not contain cyclic references
                global: {
                    config: this.initConfig(root.config),
                    // State
                    initComplete: false,
                    runningWatcher: false,
                    runningComputed: false,
                    runningPopulate: false,
                    mappingData: false,
                    collecting: false,
                    touching: false,
                    touched: false,
                    gettingContext: false,
                    contextRef: {},
                    // Instances
                    subs: new SubController(this.getContextRef.bind(this)),
                    relations: null,
                    storage: null,
                    // Function aliases
                    getInternalData: this.getInternalData.bind(this),
                    getContext: this.getContext.bind(this),
                    log: this.log.bind(this),
                    uuid: genId
                }
            };
            var self = this._private;
            // Bind static objects directly to instance
            ['utils', 'staticData'].forEach(function (type) {
                if (root[type])
                    _this[type] = root[type];
            });
            // Create storage instance
            self.global.storage = new Storage(root.storage);
            // Create relation controller instance
            self.global.relations = new RelationController(self.global);
            // init Runtime class into the global object
            this.initRuntime();
            this.registerModules(root);
            this.runAllComputed();
            this.runAllOnReady();
            this.initComplete();
        }
        Pulse.prototype.registerModules = function (root) {
            var self = this._private, namespace = {};
            // register base module
            self.modules.base = new Module('base', self.global, root);
            // alias base module public properties
            for (var _i = 0, _a = self.modules.base.public.properties; _i < _a.length; _i++) {
                var property = _a[_i];
                if (self.modules.base.public.mutableProperties.concat(self.modules.base.keys.computed).includes(property))
                    self.modules.base.public.createReactiveAlias(this, property);
                else
                    this[property] = self.modules.base.public.object[property];
            }
            // assign actions to root
            for (var _b = 0, _c = self.modules.base.keys.actions; _b < _c.length; _b++) {
                var property = _c[_b];
                this[property] = self.modules.base.public.object[property];
            }
            // optionally register request module
            if (root.request) {
                self.modules.request = new Request(self.global, root.request);
                self.keys.modules.unshift('request');
                namespace['request'] = self.modules.request.public.object;
            }
            // for each module type, and if module type exits on root, create module instances
            ['modules', 'collections', 'services'].forEach(function (category) {
                if (!root[category])
                    return;
                // declare module names as keys within respective category
                self.keys[category] = self.keys[category].concat(Object.keys(root[category]));
                // for each module instance within this category
                self.keys[category].forEach(function (instanceName) {
                    if (instanceName === 'base' || instanceName === 'request')
                        return;
                    var instanceConfig = root[category][instanceName], moduleStore = self[category], useCat = false;
                    // switch differnet categories to init the correct constructor
                    switch (category) {
                        case 'modules':
                            moduleStore[instanceName] = new Module(instanceName, self.global, instanceConfig);
                            break;
                        case 'collections':
                            moduleStore[instanceName] = new Collection(instanceName, self.global, instanceConfig);
                            break;
                        case 'services':
                            moduleStore[instanceName] = new Module(instanceName, self.global, instanceConfig);
                            useCat = true;
                            break;
                    }
                    var publicObject = moduleStore[instanceName].public.object;
                    // assign instance to namespace
                    if (useCat) {
                        // if the category does not exist on the namespace create it
                        if (!namespace[category])
                            namespace[category] = {};
                        // assign the public object from the module instance to the corresponding namspace with category
                        namespace[category][instanceName] = publicObject;
                        // the same thing as above except without category
                    }
                    else
                        namespace[instanceName] = publicObject;
                });
            });
            // preserve refrence of clean namespace object
            self.global.contextRef = __assign({}, namespace, { base: self.modules.base.public.object });
            // bind namespace to root of pulse
            for (var key in namespace)
                this[key] = namespace[key];
            if (self.global.config.baseModuleAlias)
                this['base'] = self.modules.base.public.object;
        };
        Pulse.prototype.loopModules = function (callback) {
            var _this = this;
            var keys = this._private.keys;
            var _loop_1 = function (moduleType) {
                keys[moduleType].forEach(function (moduleName) {
                    return callback(_this._private[moduleType][moduleName]);
                });
            };
            for (var moduleType in keys) {
                _loop_1(moduleType);
            }
        };
        Pulse.prototype.initRuntime = function () {
            this._private.global.runtime = new Runtime(this._private.collections, this._private.global);
        };
        Pulse.prototype.runAllComputed = function () {
            var _this = this;
            this.loopModules(function (moduleInstance) {
                return moduleInstance.keys.computed &&
                    moduleInstance.keys.computed.forEach(function (computedKey) {
                        var computed = moduleInstance.computed[computedKey];
                        // console.log(computed);
                        _this._private.global.runtime.queue({
                            type: JobType.COMPUTED_REGEN,
                            collection: moduleInstance,
                            property: computed
                        });
                        // moduleInstance.runWatchers(computed.name);
                    });
            });
            // console.log(this._private.global.runtime);
            this._private.global.runtime.run();
        };
        Pulse.prototype.runAllOnReady = function () {
            var _this = this;
            this.loopModules(function (moduleInstance) {
                if (moduleInstance.onReady)
                    moduleInstance.onReady(_this._private.global.getContext(moduleInstance));
            });
        };
        Pulse.prototype.initComplete = function () {
            this._private.global.initComplete = true;
            log('INIT COMPLETE', Object.assign({}, this));
            if (!this._private.global.config.ssr) {
                try {
                    globalThis.__pulse = this;
                    window.pulse = this;
                    window._pulse = this._private;
                }
                catch (e) { }
            }
        };
        // public wrapped(ReactComponent, mapData) {
        //   const config = this._private.global.config;
        //   if (config.framework === 'react' && config.frameworkConstructor) {
        //     return withPulse(
        //       this,
        //       config.frameworkConstructor,
        //       ReactComponent,
        //       mapData
        //     );
        //   } else {
        //     throw '[PULSE ERROR]: Error using pulse.wrapped(), framework not defined in Pulse global config (set to React constructor)';
        //   }
        // }
        Pulse.prototype.initConfig = function (config) {
            // if constructor already init
            if (!this._private) {
                // define config
                config = defineConfig(config, {
                    framework: null,
                    frameworkConstructor: null,
                    waitForMount: false,
                    autoUnmount: false,
                    computedDefault: null,
                    logJobs: false,
                    baseModuleAlias: false
                });
            }
            else {
                // merge config
                config = __assign({}, this._private.global.config, config);
            }
            // detect if framework passed in is a React constructor
            if (config.framework &&
                config.framework.hasOwnProperty('__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED')) {
                config.frameworkConstructor = config.framework;
                config.framework = 'react';
            }
            if (config.framework === 'react') {
                if (config.waitForMount != false)
                    config.waitForMount = true;
                if (config.autoUnmount != false)
                    config.autoUnmount = true;
            }
            if (this._private)
                this._private.global.config = config;
            return config;
        };
        // THIS WONT WORK
        Pulse.prototype.getInternalData = function (collection, primaryKey) {
            return this._private.collections[collection].findById(primaryKey);
        };
        Pulse.prototype.getContext = function (moduleInstance) {
            var context = {};
            this._private.global.gettingContext = true; // prevent reactive getters from tracking dependencies while building context
            if (!moduleInstance) {
                context = this._private.global.contextRef;
            }
            else
                context = moduleInstance.getSelfContext();
            // spread base context
            context = __assign({ base: this._private.modules.base.public.object }, this._private.modules.base.public.object, context);
            this._private.global.gettingContext = false;
            return context;
        };
        Pulse.prototype.getContextRef = function () {
            return this._private.global.contextRef;
        };
        Pulse.prototype.install = function (Vue) {
            this._private.global.config.framework = 'vue';
            var pulse = this;
            var config = pulse._private.global.config;
            Vue.mixin({
                beforeCreate: function () {
                    var _this = this;
                    Object.keys(pulse._private.global.contextRef).forEach(function (collection) {
                        _this['$' + collection] = pulse._private.global.contextRef[collection];
                    });
                    if (pulse.utils)
                        this.$utils = pulse.utils;
                    if (pulse.services)
                        this.$services = pulse.services;
                    if (pulse.staticData)
                        this.$staticData = pulse.staticData;
                    this.mapData = function (properties) {
                        return pulse.mapData(properties, _this, {
                            waitForMount: config.waitForMount
                        }, pulse);
                    };
                },
                mounted: function () {
                    if (this.__pulseUniqueIdentifier && config.waitForMount)
                        pulse.mount(this);
                },
                beforeDestroy: function () {
                    if (this.__pulseUniqueIdentifier && config.autoUnmount)
                        pulse.unmount(this);
                }
            });
        };
        Pulse.prototype.mount = function (instance) {
            this._private.global.subs.mount(instance);
        };
        Pulse.prototype.unmount = function (instance) {
            this._private.global.subs.unmount(instance);
        };
        Pulse.prototype.subscribe = function (instance, properties) {
            var _this = this;
            console.log(arguments);
            var uuid = instance.uuid;
            return (function () { return _this.unmount(instance); }).bind(this);
        };
        Pulse.prototype.emit = function (name, payload) {
            if (this._private.events[name])
                for (var i = 0; i < this._private.events[name].length; i++) {
                    var callback = this._private.events[name][i];
                    callback(payload);
                }
        };
        Pulse.prototype.on = function (name, callback) {
            if (!Array.isArray(this._private.events[name]))
                this._private.events[name] = [callback];
            else
                this._private.events[name].push(callback);
        };
        // re-init storage object with new config
        Pulse.prototype.updateStorage = function (storageConfig) {
            var _this = this;
            this._private.global.storage = new Storage(storageConfig);
            // re-init all collections persist to ensure correct values
            this._private.keys.collections.forEach(function (collectionName) {
                var collection = _this._private.collections[collectionName];
                collection.initPersist(collection.root.persist);
            });
        };
        Pulse.prototype.log = function (thing) {
            if (!this._private.global.config.logJobs)
                return;
            console.log('RUNTIME JOB', thing);
            // let debugMode: Set<DebugType> = this._private.global.config.debugMode;
            // if (debugMode.size === 0) return;
            // if (debugMode.has(DebugType.ERRORS)) {
            // }
            // log(DebugType.ASSERT, `There was an error with "${thing}", bad :(`);
            // const AssertMessages = {
            //   INDEX_UPDATE_FAILED: (collection, property) =>
            //     `The type ${collection} is ${property}.`
            //   // and more
            // };
            // function _log(callback) {
            // }
            // _log(({ AssertMessages }) => AssertMessages.INDEX_UPDATE_FAILED(thing, thing2));
        };
        Pulse.instance = null;
        Pulse.useFramework = useFramework;
        Pulse.React = ReactWrapper.bind(Pulse);
        return Pulse;
    }());
    //# sourceMappingURL=main.js.map

    //# sourceMappingURL=index.js.map

    return Pulse;

}));
//# sourceMappingURL=pulse.min.js.map
