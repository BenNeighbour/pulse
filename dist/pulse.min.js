!function(e,t){for(var s in t)e[s]=t[s]}(exports,function(e){var t={};function s(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,s),r.l=!0,r.exports}return s.m=e,s.c=t,s.d=function(e,t,i){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,t){if(1&t&&(e=s(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(s.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)s.d(i,r,function(t){return e[t]}.bind(null,r));return i},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="",s(s.s=2)}([function(e,t,s){const{Log:i,assert:r,warn:o}=s(1);e.exports=class{constructor({name:e,global:t},{data:s={},model:i={},actions:r={},filters:o={},indexes:n=[],groups:a=[],routes:l={},watch:h={},persist:c=[],local:p={},onLoad:d}){this._name=e,this._actionRefrence={collect:this.collect.bind(this),undo:this.undo.bind(this),move:this.move.bind(this),update:this.update.bind(this),put:this.put.bind(this),delete:this.delete.bind(this),deleteGroup:this.deleteGroup.bind(this),findById:this.findById.bind(this),getGroup:this.getGroup.bind(this),newGroup:this.newGroup.bind(this),forceUpdate:this.forceUpdate.bind(this),throttle:this.throttle.bind(this),remove:this.remove.bind(this),set:this.set.bind(this),increment:this.increment.bind(this),decrement:this.decrement.bind(this),purge:this.purge.bind(this)};this._public=this.initProxy({groups:{},data:{},actions:{},filters:{},routes:{},indexes:{}}),this._global=t,this._regenQueue=this._global.regenQueue,this._onLoad=d,this._model=i,this._filters=o,this._local=p,this._data={},this._indexes={},this.watchers={},this._storage={},this._filtersRelatedToData={},this._filtersRelatedToGroup={},this._relations={},this._groupRelations={},this._foreignGroupRelations={},this._subscribedToData={},this._persist=[],this._throttles=[],this._mutableData=[],this._indexesToRegen=[],this._filtersToForceRegen=[],this._collectionSize=0,this._primaryKey=null,this._executing=!1,this._collecting=!1,this._performingAction=!1,this._allowInternalChange=!1,this._global.internalDataRef[this._name]=this._data,this.initStorage(),this.initModel(i),this.initData(s),this.initGroups(n.concat(a)),this.initRoutes(l),this.initFilters(o),this.initActions(r),this.watchers=h,this.prepareNamespace(),this.initPersist(c)}initStorage(){this._storageIsPromise=!!this._global.storage.async,this._global.storage.get("_")instanceof Promise&&(this._storageIsPromise=!0);let e=e=>new Promise(async t=>{try{let s=await this._global.storage.get(e);return t("string"!=typeof s?s:JSON.parse(s))}catch{t(null)}}),t=e=>{let t=this._global.storage.get(e);try{return JSON.parse(t)}catch(e){return t}};this._storage.get=(s=>this._storageIsPromise?e(s):t(s)),this._storage.set=((e,t)=>{this._global.storage.set(e,JSON.stringify(t))}),this._storage.remove=(e=>this._global.storage.remove(e))}initPersist(e){e.forEach(e=>{this._persist.push(e);let t=`_${this._name}_${e}`;if(!this._public.hasOwnProperty(e))return r(`Unable to persist property "${e}" in collection "${this._name}" as it does not exist.`);let s=this.searchNamespaceForProperty(e);if(!s)return r("Unable to persist. Property does not exist.");if(this._storageIsPromise)this._storage.get(t).then(t=>{null!=t&&(this._public[s][e]=t,this._public.hasOwnProperty(e)&&(this._public[e]=t))});else{let i=this._storage.get(t);if(null==i)return;i=this.initDeepReactivity(i,e),this._allowInternalChange=!0,this._public[s][e]=i,this._public.hasOwnProperty(e)&&(this._allowInternalChange=!0,this._public[e]=i)}})}initData(e){Object.keys(e).forEach(t=>{this._mutableData.push(t),e[t]=this.initDeepReactivity(e[t],t)}),this._public.data=this.initProxy(e)}initGroups(e){this._public.groups=this.initProxy({});for(let t of e){if(this._public.groups[t]||this._indexes[t])return r(`Duplicate declaration for index ${t}`);this._indexes[t]=new Array,this._public.groups[t]=new Array}}initFilters(e){let t=Object.keys(e);for(let e of t)this._public.filters[e]=[],this._global.allFilters.push(e)}initRoutes(e){let t=Object.keys(e);for(let s of t){let t=this;this._public.routes[s]=function(){return e[s].apply(null,[t._global.request].concat(Array.prototype.slice.call(arguments)))}}}initActions(e){for(let t of Object.keys(e)){let s=this;this._public.actions[t]=function(){if(s._throttles.includes(t))return Promise.reject();s._performingAction=t;const i=Object.assign({data:s._public.data,filters:s._public.filters,groups:s._public.groups,actions:s._public.actions,routes:s._public.routes},s._global.dataRef,s._actionRefrence,{local:s._local});let r=e[t].apply(null,[i].concat(Array.prototype.slice.call(arguments)));return s._performingAction=!1,r}}}initProxy(e={},t=!1,s=!1){let i;if(t)i=Object.create({rootProperty:t});else{let e=Object.assign({},this._actionRefrence,t);i=Object.create(e)}for(let t of Object.keys(e))i[t]=e[t];return s?new Proxy(i,{set:(e,t,s)=>{if(Object.getPrototypeOf(e).rootProperty){let i=Object.getPrototypeOf(e).rootProperty;return this._mutableData.includes(i)&&(e[t]=s,this.updateSubscribers(i,this._public[i])),!0}return e[t]=s,!0},get:(e,t,s)=>e[t]}):new Proxy(i,{set:(e,t,s)=>!this._global.initComplete||this._allowInternalChange?(e[t]=s,this._allowInternalChange=!1,!0):this._mutableData.includes(t)?(e[t]=s,e[t]=this.initDeepReactivity(e[t],t),this.updateSubscribers(t,s),this.findAndUpdateDependents(t),!0):(Object.keys(this._public).includes(t)?r(`Cannot set data property "${t}" in collection "${this._name}". Filters and groups are not mutable.`):r(`Cannot set data property "${t}" in collection "${this._name}" as "${t}" does not exist.`),!0),get:(e,t,s)=>Object.getPrototypeOf(e).rootProperty?e[t]:(this._global.record&&!["filters","groups","indexes","data","actions"].includes(t)&&0===this._global.dependenciesFound.filter(e=>e.property===t&&e.collection===this._name).length&&this._global.dependenciesFound.push({property:t,collection:this._name}),e[t])})}isWatchableObject(e){return null!=e&&"object"==typeof e&&!this.isHTMLElement(e)&&!Array.isArray(e)}isHTMLElement(e){try{return e instanceof HTMLElement}catch(t){return"object"==typeof e&&1===e.nodeType&&"object"==typeof e.style&&"object"==typeof e.ownerDocument}}initDeepReactivity(e,t){let s=[];if(!this.isWatchableObject(e))return e;const i=this.initProxy(e,t,!0);for(let t of Object.keys(e))this.isWatchableObject(e[t])&&s.push({target:e,key:t});const r=()=>{let e=s;s=[];for(let i of e){let e=i.key,r=i.target;this._allowInternalChange=!0,r[e]=this.initProxy(r[e],t,!0);for(let t of Object.keys(r[e]))this.isWatchableObject(r[e][t])&&s.push({target:r[e],key:t})}s.length>0?r():this._allowInternalChange=!1};return r(),i}initModel(e){Object.keys(e).forEach(t=>{Object.keys(e[t]).forEach(s=>{"primaryKey"===s?this._primaryKey=t:"parent"===s?this.createDataRelation(t,e[t].parent,e[t].assignTo):"has"===s&&this.createGroupRelation(t,e[t].has,e[t].assignTo)})})}createDataRelation(e,t,s){if(!this._global.collectionNamespace.includes(t))return r(`"${collection}" is not a valid collection.`);this._relations[e]={},this._relations[e].fromCollectionName=t,s&&(this._relations[e].assignTo=s)}createGroupRelation(e,t,s){if(!this._global.collectionNamespace.includes(t))return r(`"${collection}" is not a valid collection.`);this._groupRelations[e]={},this._groupRelations[e].fromCollectionName=t,s&&(this._groupRelations[e].assignTo=s)}searchNamespaceForProperty(e){let t=["filters","data","groups"];for(let s of t)if(Object.keys(this._public[s]).includes(e))return s;return!1}validateNamespace(e,t){return Object.keys(e).forEach(s=>{if(e.hasOwnProperty(t))return o(`Duplicate property "${t}" on collection "${this._name}"`),!1}),!0}prepareNamespace(){Object.keys(this._public).forEach(e=>{["data","actions","groups","filters"].includes(e)&&Object.keys(this._public[e]).forEach(t=>{this.validateNamespace(this._public,t)&&(this._public[t]=this._public[e][t])})})}checkNamespace(e){return!!this._public.data.hasOwnProperty(e)||(r(`Namespace error "${e}" is already taken for collection "${this._name}".`),!1)}persistData(e,t){if(this._persist.includes(e)){let s=`_${this._name}_${e}`;i(`Persisting data with key ${s}`),this._storage.set(s,t)}}findPrimaryKey(e){let t=["id","_id"];for(let s of t)e.hasOwnProperty(s)&&(this._primaryKey=s);this._primaryKey||this.dataRejectionHandler(e,"No primary key supplied.")}createRelationForIndex(e){for(let t of Object.keys(this._relations))this._relations[t][e]=[]}analyseFilters(){if(!this._filters)return;let e=Object.keys(this._filters);for(let t of e)this.executeAndAnalyseFilter(t)}executeAndAnalyseFilter(e){i(`Analysing filter "${e}"`),this._global.record=!0,this.executeFilter(e);let t=this._global.dependenciesFound;this._global.dependenciesFound=[];for(let s of t)if(this.checkForMissingDependency(s,e))return;this.populateDependencies(t,e),this._global.generatedFilters.push(this._name+e),i(`Generated ${e} for collection ${this._name}`)}executeFilter(e){this._executing=e;const t=Object.assign({data:this._public.data,filters:this._public.filters,groups:this._public.groups,actions:this._public.actions},this._global.dataRef,this._actionRefrence,{local:this._local});let s=this._filters[e](t);this._executing=!1,this._global.record=!1,null==s&&(s=!1),this.deliverUpdate("filters",s,e)}emitToRoot(e,t={}){this._global.eventBus.message={type:e,data:t}}buildGroupFromIndex(e){let t=this._indexes[e].map(t=>{let s=this._data[t];for(let e of Object.keys(this._relations)){let t=this._relations[e],i=!!t.hasOwnProperty("assignTo")&&t.assignTo;if(s.hasOwnProperty(e)){let r=this._global.internalDataRef[t.fromCollectionName][s[e]];r&&(i?s[i]=r:s[t.fromCollectionName]=r)}}for(let t of Object.keys(this._groupRelations)){let i=this._groupRelations[t],r=!!i.hasOwnProperty("assignTo")&&i.assignTo;if(s.hasOwnProperty(t)){let o=this._global.dataRef[i.fromCollectionName][s[t]];o&&(r?s[r]=o:s[i.fromCollectionName]=o),this.emitToRoot("createForeignGroupRelation",{foreignCollection:i.fromCollectionName,foreignData:s[t],dependentCollection:this._name,dependentGroup:e})}}return s});return(this._public.hasOwnProperty(e)||this._public.groups.hasOwnProperty(e))&&this.deliverUpdate("groups",t,e),this._allowInternalChange=!0,this._public.indexes[e]=this._indexes[e],this._allowInternalChange=!1,t}internalDataModified(e){this.findGroupsToRegen(e),this.findFiltersToRegen(e),this.regenerateGroupsAndFilters()}deliverUpdate(e,t,s){for(let e of Object.keys(this._foreignGroupRelations))this.emitToRoot("rebuildGroupsWithRelations",this._foreignGroupRelations[e]);this._allowInternalChange=!0,this._public[e][s]=t,this._allowInternalChange=!1,this._public.hasOwnProperty(s)&&(this._allowInternalChange=!0,this._public[s]=t,this._allowInternalChange=!1),this.updateSubscribers(s,t)}updateSubscribers(e,t){if(i(`Updating subscribers for ${e}`),this.watchers.hasOwnProperty(e)&&setTimeout(()=>this.watchers[e](this._global.dataRef)),this.persistData(e,t),this._subscribedToData[e])for(let s of this._subscribedToData[e])if(s.component.hasOwnProperty("$vnode"))s.component.$set(s.component,s.key,t);else{let e={};e[s.key]=t,s.component.state.hasOwnProperty("_mounted")?s.component.state._mounted&&s.component.setState(e):s.component.setState(e)}}recordHistory(e,t){let s={type:e,timestamp:Date.now(),collection:this._name,fromAction:this._performingAction,data:t};this._global.history.push(s)}populateDependencies(e,t){let s=this._global.dependencyGraph;for(let i of e){let e=`${i.collection}/${i.property}`,r=s[this._name][t];r.dependencies.includes(e)||r.dependencies.push(e);let o=`${this._name}/${t}`,n=s[i.collection][i.property];n&&n.dependents&&!n.dependents.includes(o)&&n.dependents.push(o)}}checkForMissingDependency(e,t){let s=this._global;return!(!s.allFilters.includes(e.property)||s.generatedFilters.includes(e.collection+e.property))&&(i(`Dependent "${e.property}" has not been analysed yet, saving this filter to regen queue.`),this._regenQueue.push({type:"filter",property:t,collection:this._name}),!0)}findAllDependents(e){const t=this._global.dependencyGraph,s=t[this._name][e].dependents,i=[];let o=0,n=[];for(let e of s)n.push(e),i.push(e);const a=()=>{o++;let e=n;n=[];for(let s of e){let e=this.parseKey(s),r=t[e.collection][e.property].dependents;for(let e of r)n.push(e),i.push(e)}if(o>1e3)return r("Maximum stack exceeded for dependent search.");0!==n.length&&a()};return a(),i}findAndUpdateDependents(e){let t=[];if(Array.isArray(e))for(let s of e){let e=this.findAllDependents(s);for(let s of e)t.includes(s)||t.push(s)}else t=this.findAllDependents(e);i(`Found dependents: ${JSON.stringify(t)}`),this.pushDependentsToRegenQueue(t)}pushDependentsToRegenQueue(e){for(let t of e){let e=this.parseKey(t);this._regenQueue.find(t=>t.property===e.property&&t.collection===e.collection)||this._regenQueue.push({type:"filter",property:e.property,collection:e.collection})}this.emitToRoot("processRegenQueue")}forceUpdate(e){this._filters.hasOwnProperty(e)?(this._regenQueue.push({type:"filter",property:e,collection:this._name}),this.emitToRoot("processRegenQueue")):this._mutableData.includes(e)&&(this.initDeepReactivity(this._public[e],e),this.updateSubscribers(e,this._public[e]),this.findAndUpdateDependents(e))}collect(e,t){if(!e)return r(`Collect error on collection ${this._name}: Data undefined`);Array.isArray(e)||(e=[e]),this._collecting=!0;let s=!1,o=[],n=[];if(t)if(Array.isArray(t)){s=!0;for(let e of t)this.createRelationForIndex(e),this._indexesToRegen.push(e),this._indexes[e]||(this._indexes[e]=[]),o.push(e)}else this.createRelationForIndex(t),this._indexesToRegen.push(t),this._indexes[t]||(this._indexes[t]=[]),n.push(t);if(Array.isArray(e))for(let s of e)this.processDataItem(s,t,e);else this.processDataItem(e,t);this.recordHistory("collect",{dataCollected:e,indexesCreated:n,indexesModified:o}),this._collecting=!1,i(`Collected ${e.length} items in ${this._name}. With index: ${t}`),this.regenerateGroupsAndFilters()}processDataItem(e,t){let s=!0;if(this._primaryKey||this.findPrimaryKey(e),!e.hasOwnProperty(this._primaryKey))return this.dataRejectionHandler(e,"Primary key mismatch");let i=e[this._primaryKey],r=this._data[i];r&&(Object.keys(r).forEach(t=>{e.hasOwnProperty(t)||(e[t]=r[t])}),s=!1),t&&!this._indexes[t].includes(i)&&this._indexes[t].push(i);for(let s of Object.keys(this._relations)){let i=this._relations[s];Array.isArray(i[t])&&i[t].push(e[s])}Object.keys(this._data).includes(i)&&this.findGroupsToRegen(i),this.findFiltersToRegen(i,t),this._data[i]=e,s&&this._collectionSize++}findGroupsToRegen(e){i(`looking for indexes for ${e}`);for(let t of Object.keys(this._indexes))this._indexes[t].includes(e)&&!this._indexesToRegen.includes(t)&&this._indexesToRegen.push(t)}findFiltersToRegen(e,t){const s=(e,t)=>{Object.keys(this[e]).forEach(s=>{this[e][s].includes(t)&&(this._filtersToForceRegen.includes(s)||this._filtersToForceRegen.push(s))})};if(Array.isArray(t))for(let e of t)s("_filtersRelatedToGroup",e);else s("_filtersRelatedToGroup",t);s("_filtersRelatedToData",e)}regenerateGroupsAndFilters(){for(let e of this._indexesToRegen){i(`Rebuilding index ${e}`);let t=this._indexesToRegen.shift();this.buildGroupFromIndex(t),this._global.dataRef[this._name][t]&&this.findAndUpdateDependents(t)}let e=[];for(let t of this._filtersToForceRegen)e.push(`${this._name}/${t}`);this.pushDependentsToRegenQueue(e),this._filtersToForceRegen=[]}undo(){r("undo requested, coming soon!")}move(e,t,s){if(!this._indexes[t])return r(`Index "${t}" not found`);if(null!=s&&!this._indexes[s])return r(`Index "${s}" not found`);Array.isArray(e)||(e=[e]);let i={ids:e,previousSourceIndex:t,previousDestIndex:s};for(let i of e){if(!this._data[i])return r(`Data for id "${i}" not found in collection ${this._name}`);this._indexes[t]=this._indexes[t].filter(e=>e!==i),s&&this._indexes[s].push(i)}this.buildGroupFromIndex(t),s&&this.buildGroupFromIndex(s),this.recordHistory("move",i),s?this.findAndUpdateDependents([t,s]):this.findAndUpdateDependents([t])}remove(e,t){if(!this._indexes[t])return r(`Group "${t}" not found.`);if(Array.isArray(e)||(e=[e]),"object"==typeof e[0]&&e[0].hasOwnProperty(this._primaryKey))e=e.map(e=>e[this._primaryKey]);else if("number"!=typeof e[0])return r("Unable to remove data.");let s=this._indexes[t];this._indexes[t]=this._indexes[t].filter(t=>!e.includes(t)),this.buildGroupFromIndex(t),this.recordHistory("remove",{group:t,previousValue:s}),this.findAndUpdateDependents(t)}put(e,t){if(!this._indexes[t])return r(`Index "${t}" not found`);Array.isArray(e)||(e=[e]);let s=Object.assign({},this._indexes[t]);for(let s of e){if(!this._data[s])return r(`Data for id "${s}" not found in collection ${this._name}`);this._indexes[t].push(s)}this.buildGroupFromIndex(t),this.recordHistory("put",{ids:e,previousDestIndex:s}),this.findAndUpdateDependents(t)}update(e,t){if(this._data[e]){let s=this._data[e],i=Object.keys(t),r={dataId:e,previousValues:{},newValues:t};for(let e of i)r.previousValues[e]=s[e],s[e]=t[e];this.recordHistory("update",r),this.internalDataModified(e)}else r(`Data for id "${e}" not found in collection ${this._name}`)}findById(e){if(this._executing&&(this._filtersRelatedToData[this._executing]=[e]),this._data[e])return this._data[e];i(`findByID: Item "${e}" not found in collection "${this._name}"`)}getGroup(e){return this._executing&&(this._filtersRelatedToGroup[this._executing]=[e]),this._indexes[e]?this.buildGroupFromIndex(e):[]}newGroup(e,t){Object.keys(this._indexes).includes(e)||(this._indexes[e]=t,this.recordHistory("newGroup",{createdGroup:e,data:t}))}modifyGroup(e){}delete(e){if(Array.isArray(e))return r("Delete function does not yet support arrays, only primary keys for data (integers), will add soon!");if("string"==typeof e)return r("Delete function only supports primary keys for data (integers), if you're trying to delete a group, please use deleteGroup()");(e=>{let t=Object.assign({},this._data.primaryKey);delete this._data[e],this.recordHistory("delete",{deleted:t}),this.internalDataModified(e)})(e)}deleteGroup(e){if(!this._indexes[e])return r(`Group "${e}" not found.`);for(let t of this._indexes[e])this._data[t]&&delete this._data[t];let t=this._indexes[e];this._indexes[e]=[],this.buildGroupFromIndex(e),this.recordHistory("deleteGroup",{group:e,previousValue:t}),this.findAndUpdateDependents(e)}purge(){this._data={};for(let e of Object.keys(this._indexes))this._indexes[e]=[],this._indexesToRegen.push(e);this.regenerateGroupsAndFilters()}clean(){}increment(e,t,s){this.validateNumberForDataProperty(e,t,s)&&(this._data[e][t]+=s,this.recordHistory("increment",{previousValue:s}),this.internalDataModified(e))}decrement(e,t,s){this.validateNumberForDataProperty(e,t,s)&&(this._data[e][t]-=s,this.recordHistory("decrement",{previousValue:s}),this.internalDataModified(e))}throttle(e){let t=this._performingAction;this._throttles.push(t),setTimeout(()=>{this._throttles=this._throttles.filter(e=>e!==t)},e)}set(e,t){i(e,t)}validateNumberForDataProperty(e,t,s){return!(!this._data[e]||!this._data[e][t]||"number"!=typeof s||"number"!=typeof this._data[e][t])||(r(`Property ${t} for ${e} is not a number`),!1)}dataRejectionHandler(e,t){let s=`[Data Rejection] - ${t} - Data was not collected, but instead saved to the errors object("_errors") on root Pulse instance.`;this._global.errors.push({data:e,timestamp:new Date,error:s}),r(s)}parseKey(e){return{collection:e.split("/")[0],property:e.split("/")[1]}}}},function(e,t){e.exports={Log:e=>{},assert:e=>{},warn:e=>{console.error(`[Pulse] - ${e}`)}}},function(e,t,s){const i=s(3);e.exports={Library:i}},function(e,t,s){const{Log:i,assert:r,warn:o}=s(1),n=s(0),a=s(4),l=s(5);e.exports=class{constructor({storage:e,collections:t={},utils:s={},services:r={},staticData:o={},request:n={},data:a={},actions:l={},filters:h={},watch:c={},routes:p={},local:d={},groups:u=[],indexes:f=[],persist:_=[],config:g={}}){window._pulse=this,this._collections={},this._subscribers=[],this._mappedProperties={},this._eventBus=this.activateEventBus(),this._global={regenQueue:[],errors:[],history:[],allFilters:[],collectionNamespace:[],updateSubscribers:this.updateSubscribers,eventBus:this._eventBus,dependenciesFound:[],dependencyGraph:{},generatedFilters:[],record:!1,initComplete:!1,request:{},dataRef:{},internalDataRef:{},storage:{},relations:{},config:g},this.initStorage(e),this.initCollections(t,{data:a,indexes:f,actions:l,filters:h,routes:p,groups:u,watch:c,persist:_,local:d},n),this.utils=s,this.services=r,this.staticData=o,this.buildGlobalDataRefrenceTree(),this.prepareDependencyGraph(),this.executeAllFilters(),this.processRegenQueue(),this._global.initComplete=!0,i("INIT_COMPLETE")}install(e){const t=window._pulse;let s=this;e.mixin({beforeCreate(){Object.keys(s._global.dataRef).forEach(e=>{this["$"+e]=s._global.dataRef[e]}),this.$utils=t.utils,this.$services=t.services,this.$staticData=t.staticData,this.mapData=s.mapData}})}mapData(e,t){const s={},i=window._pulse;return e&&i.normalizeMap(e).forEach(({key:e,val:r})=>{let o=r.split("/")[0],n=r.split("/")[1];if(!i.hasOwnProperty(o))return;let a=i._collections[o]._subscribedToData,l={component:t||this,key:e};a.hasOwnProperty(n)?a[n].push(l):a[n]=[l],s[e]=i[o][n]}),s}mapCollections(){const e={};return Object.keys(this._global.dataRef).forEach(t=>{e[t]=this._global.dataRef[t]}),e}normalizeMap(e){return Array.isArray(e)?e.map(e=>({key:e,val:e})):Object.keys(e).map(t=>({key:t,val:e[t]}))}activateEventBus(){return new Proxy({message:null},{set:(e,t,s)=>("processRegenQueue"===s.type&&this.processRegenQueue(),"createForeignGroupRelation"===s.type&&(this._collections[s.data.foreignCollection]._foreignGroupRelations[s.data.foreignGroup]={collection:s.data.dependentCollection,groupToRegen:s.data.dependentGroup}),"rebuildGroupsWithRelations"===s.type&&this._collections[s.data.collection].buildGroupFromIndex(s.data.groupToRegen),e[t]="waiting",!0)})}initStorage(e={}){let t="custom";if(e.async||(e.async=!1),"sessionStorage"===e)t="sessionStorage",this.assignStorage(sessionStorage,t,e.async);else if(e&&e.set&&e.get)t="custom",this.assignStorage(e,t,e.async);else{if(!window.localStorage)return r("No storage API present, data will not persist");t="localStorage",this.assignStorage(localStorage,t,e.async)}}assignStorage(e,t,s){const i={type:t,async:s};e.set&&(i.set=e.set.bind(e)),e.setItem&&(i.set=e.setItem.bind(e)),e.get&&(i.get=e.get.bind(e)),e.getItem&&(i.get=e.getItem.bind(e)),e.remove&&(i.remove=e.remove.bind(e)),e.removeItem&&(i.remove=e.removeItem.bind(e)),e.clear&&(i.clear=e.clear.bind(e)),this._global.storage=i}prepareDependencyGraph(){let e=this._global.dependencyGraph,t=this._global.collectionNamespace;for(let s of t){e[s]={};let t=this._collections[s]._public,i=[],r=["filters","groups","data"];for(let e of r)Object.keys(t[e]).forEach(e=>i.push(e));for(let t of i)e[s][t]={dependencies:[],dependents:[]}}}initCollections(e,t,s){this._collections.base=new a(this._global,t,s),this._collections.request=new l(this._global,s),this._global.collectionNamespace=["base","request"],Object.keys(e).forEach(t=>{this._global.collectionNamespace.push(t),this._collections[t]=new n({name:t,global:this._global},e[t])}),Object.keys(this._collections).forEach(e=>{this[e]?r(`Collection name conflict, instance already has "${e}" thus it will not be accessable on the root state tree.`):this[e]=this._collections[e]._public})}buildGlobalDataRefrenceTree(){if(this._collections){let e=Object.keys(this._collections);for(let t of e)this._global.dataRef[t]=this._collections[t]._public}}executeAllFilters(){let e=Object.keys(this._collections);for(let t of e)this._collections[t].analyseFilters()}processRegenQueue(){if(0!==this._global.regenQueue.length){i(`Regen queue processing. There are ${this._global.regenQueue.length} in the queue.`);for(let e of this._global.regenQueue){const e=this._global.regenQueue.shift(),t=`${e.collection}/${e.property}`;if(t===this.lastRegenerated)return o(`Prevented infinate loop for ${t}`),void(this.lastRegenerated="");this._collections[e.collection].executeAndAnalyseFilter(e.property),this.lastRegenerated=t,i(`There are ${this._global.regenQueue.length} properties left to regenerate.`)}this._global.regenQueue.length>0?this.processRegenQueue():this.lastRegenerated=""}}}},function(e,t,s){const i=s(0);e.exports=class extends i{constructor(e,{data:t={},actions:s={},routes:i={},filters:r={},groups:o=[],watch:n={},persist:a=[]}){t.isAuthenticated=!1,t.appReady=!1,a.push("isAuthenticated"),super({name:"base",global:e},{data:t,actions:s,groups:o,persist:a,routes:i,filters:r,watch:n})}}},function(e,t,s){const i=s(0);e.exports=class extends i{constructor(e,{baseURL:t,requestIntercept:s,responseIntercept:i,mode:r,credentials:o,headers:n,saveHistory:a}){let l={baseURL:t,mode:"cors",credentials:"include",headers:{"Content-Type":"application/json",Accept:"application/json"}};t||(l.baseURL=null),n&&Object.keys(n).forEach(e=>{l.headers[e]=n[e]}),super({name:"request",global:e},{groups:[],data:l,persist:["baseURL"]}),this._requestIntercept=s,this._responseIntercept=i,this._saveHistory=void 0===this._saveHistory;this.fetchOptions={},o&&(l.credentials=o),r&&(l.mode=r),this.fetchOptions.credentials=l.credentials,this.fetchOptions.mode=l.mode,this._global.request={get:this.get.bind(this),post:this.post.bind(this),put:this.put.bind(this),patch:this.patch.bind(this),delete:this.delete.bind(this)}}send(e,t,s,i){return new Promise((r,o)=>{let n=Object.assign({},this._public.headers);i&&Object.keys(i).forEach(e=>{n.headers[e]=i[e]});let a=`${this._global.dataRef.request.baseURL}/${e}`;s=JSON.stringify(s);const l=Object.assign({headers:n,method:t.toUpperCase(),body:"get"==t?null:s},this.fetchOptions);let h={};this._requestIntercept&&this._requestIntercept(),fetch(a,l).then(e=>{h=e;const t=e.headers.get("content-type");return t&&-1!==t.indexOf("application/json")?e.json():e.text()}).then(e=>{this._saveHistory||this.collect({id:Date.now(),status:e.status,timestamp:new Date,response:e}),e.status&&e.status.code&&(e.status.code.toString().startsWith("4")||e.status.code.toString().startsWith("5"))&&o(e);let t=Object.create({response:e=>h});for(let s of Object.keys(e))t[s]=e[s];this._responseIntercept&&this._responseIntercept(),r(t)}).catch(o)})}get(e,t){return this.send(e,"get",{},t)}post(e,t,s){return this.send(e,"post",t,s)}patch(e,t,s){return this.send(e,"patch",t,s)}delete(e,t,s){return this.send(e,"delete",t,s)}put(e,t,s){return this.send(e,"put",t,s)}}}]));