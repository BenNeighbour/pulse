!function(e,t){for(var i in t)e[i]=t[i]}(exports,function(e){var t={};function i(s){if(t[s])return t[s].exports;var r=t[s]={i:s,l:!1,exports:{}};return e[s].call(r.exports,r,r.exports,i),r.l=!0,r.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(i.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)i.d(s,r,function(t){return e[t]}.bind(null,r));return s},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=2)}([function(e,t,i){const{Log:s,assert:r,warn:o}=i(1);e.exports=class{constructor({name:e,global:t},{data:i={},model:s={},actions:r={},filters:o={},indexes:n=[],groups:a=[],routes:l={},watch:h={},persist:c=[],local:d={},onLoad:p}){this._name=e,this._actionRefrence={collect:this.collect.bind(this),undo:this.undo.bind(this),move:this.move.bind(this),update:this.update.bind(this),put:this.put.bind(this),delete:this.delete.bind(this),findById:this.findById.bind(this),getGroup:this.getGroup.bind(this),newGroup:this.newGroup.bind(this),forceUpdate:this.forceUpdate.bind(this),throttle:this.throttle.bind(this),remove:this.remove.bind(this),removeGroup:this.remove.bind(this),set:this.set.bind(this)};this._public=this.initProxy({groups:{},data:{},actions:{},filters:{},routes:{},indexes:{}}),this._global=t,this._regenQueue=this._global.regenQueue,this._onLoad=p,this._model=s,this._filters=o,this._local=d,this._data={},this._indexes={},this.watchers={},this._filtersRelatedToData={},this._filtersRelatedToGroup={},this._relations={},this._groupRelations={},this._foreignGroupRelations=[],this._subscribedToData={},this._persist=[],this._throttles=[],this._mutableData=[],this._indexesToRegen=[],this._filtersToForceRegen=[],this._collectionSize=0,this._primaryKey=null,this._executing=!1,this._collecting=!1,this._performingAction=!1,this._allowInternalChange=!1,this._global.internalDataRef[this._name]=this._data,this._storage={},this._storage.get=(e=>JSON.parse(this._global.storage.get(e))),this._storage.set=((e,t)=>this._global.storage.set(e,JSON.stringify(t))),this.initModel(s),this.initData(i),this.initGroups(n.concat(a)),this.initRoutes(l),this.initFilters(o),this.initActions(r),this.watchers=h,this.prepareNamespace(),this.initPersist(c)}initData(e){Object.keys(e).forEach(t=>{this._mutableData.push(t),this.initDeepReactivity(e,t)}),this._public.data=this.initProxy(e)}initGroups(e){this._public.groups=this.initProxy({});for(let t of e){if(this._public.groups[t]||this._indexes[t])return r(`Duplicate declaration for index ${t}`);this._indexes[t]=new Array,this._public.groups[t]=new Array}}initFilters(e){let t=Object.keys(e);for(let e of t)this._public.filters[e]=[],this._global.allFilters.push(e)}initRoutes(e){let t=Object.keys(e);for(let i of t)this._public.routes[i]=(t=>e[i](this._global.request,t))}initActions(e){for(let t of Object.keys(e))this._public.actions[t]=(i=>{if(this._throttles.includes(t))return Promise.reject();this._performingAction=t;const s=Object.assign({data:this._public.data,filters:this._public.filters,groups:this._public.groups,actions:this._public.actions,routes:this._public.routes},this._global.dataRef,this._actionRefrence,{local:this._local});let r=e[t](s,i);return this._performingAction=!1,r})}initPersist(e=[]){for(let t of e){this._persist.push(t);let e=`_${this._name}_${t}`;if(!this._public.hasOwnProperty(t))return r(`Unable to persist property "${t}" in collection "${this._name}" as it does not exist.`);let i=this.searchNamespaceForProperty(t),s=this._storage.get(e);s?i?(this._allowInternalChange=!0,this._public[i][t]=s,this._allowInternalChange=!1,this._public.hasOwnProperty(t)&&(this._allowInternalChange=!0,this._public[t]=s,this._allowInternalChange=!1),this.initDeepReactivity(this._public,t)):r("Unable to persist. Could not determin property type."):i&&this._storage.set(e,this._public[i][t])}}initProxy(e={},t=!1,i=!1){let s;if(t)s=Object.create({rootProperty:t});else{let e=Object.assign({},this._actionRefrence,t);s=Object.create(e)}for(let t of Object.keys(e))s[t]=e[t];return i?new Proxy(s,{set:(e,t,i)=>{if(Object.getPrototypeOf(e).rootProperty){let s=Object.getPrototypeOf(e).rootProperty;return this._mutableData.includes(s)&&(e[t]=i,this.updateSubscribers(s,this._public[s])),!0}return e[t]=i,!0},get:(e,t,i)=>e[t]}):new Proxy(s,{set:(e,t,i)=>!this._global.initComplete||this._allowInternalChange?(e[t]=i,this._allowInternalChange=!1,!0):this._mutableData.includes(t)?(e[t]=i,this.initDeepReactivity(e,t),this.updateSubscribers(t,i),this.findAndUpdateDependents(t),!0):(Object.keys(this._public).includes(t)?r(`Cannot set data property "${t}" in collection "${this._name}". Filters and groups are not mutable.`):r(`Cannot set data property "${t}" in collection "${this._name}" as "${t}" does not exist.`),!0),get:(e,t,i)=>Object.getPrototypeOf(e).rootProperty?e[t]:(this._global.record&&!["filters","groups","indexes","data","actions"].includes(t)&&0===this._global.dependenciesFound.filter(e=>e.property===t&&e.collection===this._name).length&&this._global.dependenciesFound.push({property:t,collection:this._name}),e[t])})}isWatchableObject(e){return!(null==e||"object"!=typeof e||e instanceof HTMLElement||Array.isArray(e))}initDeepReactivity(e,t){let i,s=[];if(this.isWatchableObject(e[t])){i=Object.getPrototypeOf(e).rootProperty?Object.getPrototypeOf(e).rootProperty:t,this._allowInternalChange=!0,e[t]=this.initProxy(e[t],i,!0);for(let i of Object.keys(e[t]))this.isWatchableObject(e[t][i])&&s.push({target:e[t],key:i});const r=()=>{let e=s;s=[];for(let t of e){let e=t.key,r=t.target;r[e]=this.initProxy(r[e],i,!0);for(let t of Object.keys(r[e]))this.isWatchableObject(r[e][t])&&s.push({target:r[e],key:t})}s.length>0?r():this._allowInternalChange=!1};r()}}initModel(e){Object.keys(e).forEach(t=>{Object.keys(e[t]).forEach(i=>{"primaryKey"===i?this._primaryKey=t:"parent"===i?this.createDataRelation(t,e[t].parent,e[t].assignTo):"has"===i&&this.createGroupRelation(t,e[t].has,e[t].assignTo)})})}createDataRelation(e,t,i){if(!this._global.collectionNamespace.includes(t))return r(`"${collection}" is not a valid collection.`);this._relations[e]={},this._relations[e].fromCollectionName=t,i&&(this._relations[e].assignTo=i)}createGroupRelation(e,t,i){if(!this._global.collectionNamespace.includes(t))return r(`"${collection}" is not a valid collection.`);this._groupRelations[e]={},this._groupRelations[e].fromCollectionName=t,i&&(this._groupRelations[e].assignTo=i),this.emitToRoot("createForeignGroupRelation",{collection:this._name})}searchNamespaceForProperty(e){let t=["filters","data","groups"];for(let i of t)if(Object.keys(this._public[i]).includes(e))return i;return!1}validateNamespace(e,t){return Object.keys(e).forEach(i=>{if(e.hasOwnProperty(t))return o(`Duplicate property "${t}" on collection "${this._name}"`),!1}),!0}prepareNamespace(){Object.keys(this._public).forEach(e=>{["data","actions","groups","filters"].includes(e)&&Object.keys(this._public[e]).forEach(t=>{this.validateNamespace(this._public,t)&&(this._public[t]=this._public[e][t])})})}checkNamespace(e){return!!this._public.data.hasOwnProperty(e)||(r(`Namespace error "${e}" is already taken for collection "${this._name}".`),!1)}persistData(e,t){if(this._persist.includes(e)){let i=`_${this._name}_${e}`;s(`Persisting data with key ${i}`),this._storage.set(i,t)}}findPrimaryKey(e){let t=["id","_id"];for(let i of t)e.hasOwnProperty(i)&&(this._primaryKey=i);this._primaryKey||this.dataRejectionHandler(e,"No primary key supplied.")}createRelationForIndex(e){for(let t of Object.keys(this._relations))this._relations[t][e]=[]}createRelationForGroup(e){}analyseFilters(){if(!this._filters)return;let e=Object.keys(this._filters);for(let t of e)this.executeAndAnalyseFilter(t)}executeAndAnalyseFilter(e){s(`Analysing filter "${e}"`),this._global.record=!0,this.executeFilter(e);let t=this._global.dependenciesFound;this._global.dependenciesFound=[];for(let i of t)if(this.checkForMissingDependency(i,e))return;this.populateDependencies(t,e),this._global.generatedFilters.push(this._name+e),s(`Generated ${e} for collection ${this._name}`)}executeFilter(e){this._executing=e;const t=Object.assign({data:this._public.data,filters:this._public.filters,groups:this._public.groups,actions:this._public.actions},this._global.dataRef,this._actionRefrence,{local:this._local});let i=this._filters[e](t);this._executing=!1,this._global.record=!1,null==i&&(i=!1),this.deliverUpdate("filters",i,e)}emitToRoot(e,t={}){this._global.eventBus.message={type:e,data:t}}rebuildGroupsWithRelations(){}buildGroupFromIndex(e){let t=this._indexes[e].map(e=>{let t=this._data[e];for(let e of Object.keys(this._relations)){let i=this._relations[e],s=!!i.hasOwnProperty("assignTo")&&i.assignTo;if(t.hasOwnProperty(e)){let r=this._global.internalDataRef[i.fromCollectionName][t[e]];r&&(s?t[s]=r:t[i.fromCollectionName]=r)}}for(let e of Object.keys(this._groupRelations)){let i=this._groupRelations[e],s=!!i.hasOwnProperty("assignTo")&&i.assignTo;if(t.hasOwnProperty(e)){let r=this._global.dataRef[i.fromCollectionName][e];r&&(s?t[s]=r:t[i.fromCollectionName]=r)}}return t});if((this._public.hasOwnProperty(e)||this._public.groups.hasOwnProperty(e))&&this.deliverUpdate("groups",t,e),this._allowInternalChange=!0,this._public.indexes[e]=this._indexes[e],this._allowInternalChange=!1,this._foreignGroupRelations)for(let e of this._foreignGroupRelations)this.emitToRoot("rebuildGroupsWithRelations",{collection:e});return t}internalDataModified(e){this.findGroupsToRegen(e),this.findFiltersToRegen(e),this.regenerateGroupsAndFilters()}deliverUpdate(e,t,i){this._allowInternalChange=!0,this._public[e][i]=t,this._allowInternalChange=!1,this._public.hasOwnProperty(i)&&(this._allowInternalChange=!0,this._public[i]=t,this._allowInternalChange=!1),this.updateSubscribers(i,t)}updateSubscribers(e,t){if(s(`Updating subscribers for ${e}`),this.watchers.hasOwnProperty(e)&&setTimeout(()=>this.watchers[e](this._global.dataRef)),this.persistData(e,t),this._subscribedToData[e])for(let i of this._subscribedToData[e])i.component.$set(i.component,i.key,t)}recordHistory(e,t){let i={type:e,timestamp:Date.now(),collection:this._name,fromAction:this._performingAction,data:t};this._global.history.push(i)}populateDependencies(e,t){let i=this._global.dependencyGraph;for(let s of e){let e=`${s.collection}/${s.property}`,r=i[this._name][t];r.dependencies.includes(e)||r.dependencies.push(e);let o=`${this._name}/${t}`,n=i[s.collection][s.property];n&&n.dependents&&!n.dependents.includes(o)&&n.dependents.push(o)}}checkForMissingDependency(e,t){let i=this._global;return!(!i.allFilters.includes(e.property)||i.generatedFilters.includes(e.collection+e.property))&&(s(`Dependent "${e.property}" has not been analysed yet, saving this filter to regen queue.`),this._regenQueue.push({type:"filter",property:t,collection:this._name}),!0)}findAllDependents(e){const t=this._global.dependencyGraph,i=t[this._name][e].dependents,s=[];let o=0,n=[];for(let e of i)n.push(e),s.push(e);const a=()=>{o++;let e=n;n=[];for(let i of e){let e=this.parseKey(i),r=t[e.collection][e.property].dependents;for(let e of r)n.push(e),s.push(e)}if(o>1e3)return r("Maximum stack exceeded for dependent search.");0!==n.length&&a()};return a(),s}findAndUpdateDependents(e){let t=[];if(Array.isArray(e))for(let i of e){let e=this.findAllDependents(i);for(let i of e)t.includes(i)||t.push(i)}else t=this.findAllDependents(e);s(`Found dependents: ${JSON.stringify(t)}`),this.pushDependentsToRegenQueue(t)}pushDependentsToRegenQueue(e){for(let t of e){let e=this.parseKey(t);this._regenQueue.find(t=>t.property===e.property&&t.collection===e.collection)||this._regenQueue.push({type:"filter",property:e.property,collection:e.collection})}this.emitToRoot("processRegenQueue")}forceUpdate(e){this._regenQueue.push({type:"filter",property:e,collection:this._name}),this.emitToRoot("processRegenQueue")}collect(e,t){if(!e)return r(`Collect error on collection ${this._name}: Data undefined`);Array.isArray(e)||(e=[e]),this._collecting=!0;let i=!1,s=[],o=[];if(t)if(Array.isArray(t)){i=!0;for(let e of t)this.createRelationForIndex(e),this._indexesToRegen.push(e),this._indexes[e]||(this._indexes[e]=[]),s.push(e)}else this.createRelationForIndex(t),this._indexesToRegen.push(t),this._indexes[t]||(this._indexes[t]=[]),o.push(t);if(Array.isArray(e))for(let i of e)this.processDataItem(i,t,e);else this.processDataItem(e,t);this.recordHistory("collect",{dataCollected:e,indexesCreated:o,indexesModified:s}),this._collecting=!1,console.log(`Collected ${e.length} items in ${this._name}. With index: ${t}`),this.regenerateGroupsAndFilters()}processDataItem(e,t){let i=!0;if(this._primaryKey||this.findPrimaryKey(e),!e.hasOwnProperty(this._primaryKey))return this.dataRejectionHandler(e,"Primary key mismatch");let s=e[this._primaryKey],r=this._data[s];r&&(Object.keys(r).forEach(t=>{e.hasOwnProperty(t)||(e[t]=r[t])}),i=!1),t&&!this._indexes[t].includes(s)&&this._indexes[t].push(s);for(let i of Object.keys(this._relations)){let s=this._relations[i];Array.isArray(s[t])&&s[t].push(e[i])}Object.keys(this._data).includes(s)&&this.findGroupsToRegen(s),this.findFiltersToRegen(s,t),this._data[s]=e,i&&this._collectionSize++}findGroupsToRegen(e){s(`looking for indexes for ${e}`);for(let t of Object.keys(this._indexes))this._indexes[t].includes(e)&&!this._indexesToRegen.includes(t)&&this._indexesToRegen.push(t)}findFiltersToRegen(e,t){const i=(e,t)=>{Object.keys(this[e]).forEach(i=>{this[e][i].includes(t)&&(this._filtersToForceRegen.includes(i)||this._filtersToForceRegen.push(i))})};if(Array.isArray(t))for(let e of t)i("_filtersRelatedToGroup",e);else i("_filtersRelatedToGroup",t);i("_filtersRelatedToData",e)}regenerateGroupsAndFilters(){for(let e of this._indexesToRegen){s(`Rebuilding index ${e}`);let t=this._indexesToRegen.shift();this.buildGroupFromIndex(t),this._global.dataRef[this._name][t]&&this.findAndUpdateDependents(t)}let e=[];for(let t of this._filtersToForceRegen)e.push(`${this._name}/${t}`);this.pushDependentsToRegenQueue(e),this._filtersToForceRegen=[]}undo(){s("undo requested, coming soon!")}move(e,t,i){if(!this._indexes[t])return r(`Index "${t}" not found`);if(!this._indexes[i])return r(`Index "${i}" not found`);Array.isArray(e)||(e=[e]);let s={ids:e,previousSourceIndex:t,previousDestIndex:i};for(let s of e){if(!this._data[s])return r(`Data for id "${s}" not found in collection ${this._name}`);this._indexes[t]=this._indexes[t].filter(e=>e!==s),this._indexes[i].push(s)}this.buildGroupFromIndex(t),this.buildGroupFromIndex(i),this.recordHistory("move",s),this.findAndUpdateDependents([t,i])}remove(e,t){if(!this._indexes[t])return r(`Group "${t}" not found.`);if(Array.isArray(e)||(e=[e]),e[0].hasOwnProperty(this._primaryKey))e=e.map(e=>e[this._primaryKey]);else if("number"!=typeof e[0])return r("Unable to remove data.");let i=this._indexes[t];this._indexes[t]=this._indexes[t].filter(t=>!e.includes(t)),this.buildGroupFromIndex(t),this.recordHistory("remove",{group:t,previousValue:i}),this.findAndUpdateDependents(t)}put(e,t){if(!this._indexes[t])return r(`Index "${t}" not found`);Array.isArray(e)||(e=[e]);let i=Object.assign({},this._indexes[t]);for(let i of e){if(!this._data[i])return r(`Data for id "${i}" not found in collection ${this._name}`);this._indexes[t].push(i)}this.buildGroupFromIndex(t),this.recordHistory("put",{ids:e,previousDestIndex:i}),this.findAndUpdateDependents(t)}update(e,t){if(this._data[e]){let i=this._data[e],s=Object.keys(t),o={dataId:e,previousValues:{},newValues:t};for(let n of s)i.hasOwnProperty(n)||r(`Data "${e}" does not have property "${n}" to update`),o.previousValues[n]=i[n],i[n]=t[n];this.recordHistory("update",o),this.internalDataModified(e)}else r(`Data for id "${e}" not found in collection ${this._name}`)}findById(e){if(this._executing&&(this._filtersRelatedToData[this._executing]=[e]),this._data[e])return this._data[e];s(`findByID: Item "${e}" not found in collection "${this._name}"`)}getGroup(e){return this._executing&&(this._filtersRelatedToGroup[this._executing]=[e]),this._indexes[e]?this.buildGroupFromIndex(e):[]}newGroup(e,t){Object.keys(this._indexes).includes(e)||(this._indexes[e]=t,this.recordHistory("newGroup",{createdGroup:e,data:t}))}modifyGroup(e){}delete(e){const t=e=>{let t=Object.assign({},this._data.primaryKey);delete this._data[e],this.recordHistory("delete",{deleted:t}),this.internalDataModified(e)};if(Array.isArray(e))for(let i of e)t(i);else t(e)}deleteGroup(e){if(!this._indexes[e])return r(`Group "${e}" not found.`);for(let t of this._indexes[e])this._data[t]&&delete this._data[t];let t=this._indexes[e];this._indexes[e]=[],this.buildGroupFromIndex(e),this.recordHistory("deleteGroup",{group:e,previousValue:t}),this.findAndUpdateDependents(e)}clean(){}increment(e,t,i){validateNumberForDataProperty(e,t,i)&&(this._data[e][t]+=i,this.recordHistory("increment",{previousValue:i}),this.internalDataModified(e))}decrement(e,t,i){validateNumberForDataProperty(e,t,i)&&(this._data[e][t]-=i,this.recordHistory("decrement",{previousValue:i}),this.internalDataModified(e))}throttle(e){let t=this._performingAction;this._throttles.push(t),setTimeout(()=>{this._throttles=this._throttles.filter(e=>e!==t)},e)}set(e,t){console.log(e,t)}validateNumberForDataProperty(e,t,i){return!(!this._data[e]||!this._data[e][t]||"number"!=typeof i||"number"!=typeof this._data[e][t])||(r(`Property ${t} for ${e} is not a number`),!1)}dataRejectionHandler(e,t){let i=`[Data Rejection] - ${t} - Data was not collected, but instead saved to the errors object("_errors") on root Pulse instance.`;this._global.errors.push({data:e,timestamp:new Date,error:i}),r(i)}parseKey(e){return{collection:e.split("/")[0],property:e.split("/")[1]}}}},function(e,t){e.exports={Log:e=>{},assert:e=>{},warn:e=>{console.error(`[Pulse] - ${e}`)}}},function(e,t,i){const s=i(3);e.exports={Library:s}},function(e,t,i){const{Log:s,assert:r,warn:o}=i(1),n=i(0),a=i(4),l=i(5);e.exports=class{constructor({collections:e={},utils:t={},services:i={},request:r={},storage:o,data:n={},groups:a=[],indexes:l=[],persist:h=[],actions:c={},filters:d={},watch:p={},routes:u={},local:f={}}){window._pulse=this,this._collections=Object.create(null),this._subscribers=[],this._mappedProperties={},this._eventBus=this.activateEventBus(),this._global={regenQueue:[],errors:[],history:[],allFilters:[],collectionNamespace:[],updateSubscribers:this.updateSubscribers,eventBus:this._eventBus,dependenciesFound:[],dependencyGraph:{},generatedFilters:[],record:!1,initComplete:!1,request:{},dataRef:{},internalDataRef:{},storage:{},relations:{}},this.initStorage(o),this.initCollections(e,{data:n,indexes:l,actions:c,filters:d,routes:u,groups:a,watch:p,persist:h,local:f},r),this.buildGlobalDataRefrenceTree(),this.prepareDependencyGraph(),this.executeAllFilters(),this.processRegenQueue(),this._global.initComplete=!0,s("INIT_COMPLETE")}install(e){let t=this;e.mixin({beforeCreate(){Object.keys(t._global.dataRef).forEach(e=>{this["$"+e]=t._global.dataRef[e]}),this.mapData=t.mapData}})}mapData(e){const t={},i=window._pulse;return e&&i.normalizeMap(e).forEach(({key:e,val:s})=>{let r=s.split("/")[0],o=s.split("/")[1];if(!i.hasOwnProperty(r))return;let n=i._collections[r]._subscribedToData,a={component:this,key:e};n.hasOwnProperty(o)?n[o].push(a):n[o]=[a],t[e]=i[r][o]||null}),t}mapCollections(){const e={};return Object.keys(this._global.dataRef).forEach(t=>{e[t]=this._global.dataRef[t]}),e}normalizeMap(e){return Array.isArray(e)?e.map(e=>({key:e,val:e})):Object.keys(e).map(t=>({key:t,val:e[t]}))}activateEventBus(){return new Proxy({message:null},{set:(e,t,i)=>("processRegenQueue"===i.type&&this.processRegenQueue(),i.type,"rebuildGroupsWithRelations"===i.type&&this._collections[i.data.collection].rebuildGroupsWithRelations(),e[t]="waiting",!0)})}initStorage(e){let t="localStorage";if("sessionStorage"===e)this.assignStorage(sessionStorage,t),t="sessionStorage";else if(e&&e.set&&e.get&&e.remove)this.assignStorage(e,t),t="custom";else{if(!window.localStorage)return r("No storage API present, data will not persist");this.assignStorage(localStorage,t)}}assignStorage(e,t){const i={type:t};e.set&&(i.set=e.set.bind(e)),e.setItem&&(i.set=e.setItem.bind(e)),e.get&&(i.get=e.get.bind(e)),e.getItem&&(i.get=e.getItem.bind(e)),e.remove&&(i.remove=e.remove.bind(e)),e.removeItem&&(i.remove=e.removeItem.bind(e)),e.clear&&(i.clear=e.clear.bind(e)),this._global.storage=i}prepareDependencyGraph(){let e=this._global.dependencyGraph,t=this._global.collectionNamespace;for(let i of t){e[i]={};let t=this._collections[i]._public,s=[],r=["filters","groups","data"];for(let e of r)Object.keys(t[e]).forEach(e=>s.push(e));for(let t of s)e[i][t]={dependencies:[],dependents:[]}}}initCollections(e,t,i){this._collections.base=new a(this._global,t,i),this._collections.request=new l(this._global,i),this._global.collectionNamespace=["base","request"],Object.keys(e).forEach(t=>{this._global.collectionNamespace.push(t),this._collections[t]=new n({name:t,global:this._global},e[t])}),Object.keys(this._collections).forEach(e=>{this[e]?r(`Collection name conflict, instance already has "${e}" thus it will not be accessable on the root state tree.`):this[e]=this._collections[e]._public})}buildGlobalDataRefrenceTree(){if(this._collections){let e=Object.keys(this._collections);for(let t of e)this._global.dataRef[t]=this._collections[t]._public}}executeAllFilters(){let e=Object.keys(this._collections);for(let t of e)this._collections[t].analyseFilters()}processRegenQueue(){if(0!==this._global.regenQueue.length){s(`Regen queue processing. There are ${this._global.regenQueue.length} in the queue.`);for(let e of this._global.regenQueue){const e=this._global.regenQueue.shift(),t=`${e.collection}/${e.property}`;if(t===this.lastRegenerated)return o(`Prevented infinate loop for ${t}`),void(this.lastRegenerated="");this._collections[e.collection].executeAndAnalyseFilter(e.property),this.lastRegenerated=t,s(`There are ${this._global.regenQueue.length} properties left to regenerate.`)}this._global.regenQueue.length>0?this.processRegenQueue():this.lastRegenerated=""}}}},function(e,t,i){const s=i(0);e.exports=class extends s{constructor(e,{data:t={},actions:i={},routes:s={},filters:r={},groups:o=[],watch:n={},persist:a=[]}){t.isAuthenticated=!1,t.appReady=!1,t.pendingRequests=[],a.push("isAuthenticated"),super({name:"base",global:e},{data:t,actions:i,groups:o,persist:a,routes:s,filters:r,watch:n})}}},function(e,t,i){const s=i(0);e.exports=class extends s{constructor(e,{baseURL:t,requestIntercept:i,responseIntercept:s,mode:r,credentials:o,headers:n}){let a={baseURL:t,mode:"cors",credentials:"include"};t||(a.baseURL=null),super({name:"request",global:e},{groups:[],data:a,persist:["baseURL"]});this.standardHeader={headers:{"Content-Type":"application/json",Accept:"application/json"}},o&&(a.credentials=o),r&&(a.mode=r),this.standardHeader.credentials=a.credentials,this.standardHeader.mode=a.mode,n&&Object.keys(n).forEach(e=>{this.standardHeader.headers[e]=n[e]}),this._global.request={get:this.get.bind(this),post:this.post.bind(this),put:this.put.bind(this),patch:this.patch.bind(this),delete:this.delete.bind(this)}}send(e,t,i,s){return new Promise((r,o)=>{let n=this.standardHeader;s&&Object.keys(s).forEach(e=>{n.headers[e]=s[e]});let a=`${this._global.dataRef.request.baseURL}/${e}`;i=JSON.stringify(i);const l=Object.assign(n,{method:t.toUpperCase(),body:"get"==t?null:i});fetch(a,l).then(e=>{const t=e.headers.get("content-type");return t&&-1!==t.indexOf("application/json")?e.json():e.text()}).then(e=>{this.collect({id:Date.now(),status:e.status,timestamp:new Date,response:e}),e.status&&e.status.code&&(e.status.code.toString().startsWith("4")||e.status.code.toString().startsWith("5"))&&o(e),r(e)}).catch(o)})}get(e,t){return this.send(e,"get",{},t)}post(e,t,i){return this.send(e,"post",t,i)}patch(e,t,i){return this.send(e,"patch",t,i)}delete(e,t,i){return this.send(e,"delete",t,i)}put(e,t,i){return this.send(e,"put",t,i)}}}]));