{"version":3,"file":"pulse.cjs.min.js","sources":["../lib/helpers.ts","../node_modules/@babel/runtime/helpers/defineProperty.js","../node_modules/@babel/runtime/helpers/objectSpread.js","../node_modules/@babel/runtime/helpers/classCallCheck.js","../node_modules/@babel/runtime/helpers/createClass.js","../node_modules/@babel/runtime/helpers/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/inherits.js","../lib/wrappers/ReactWithPulse.js","../lib/Dep.ts","../lib/computed.ts","../lib/relationController.ts","../lib/runtime.ts","../lib/dep.ts","../lib/reactive.ts","../lib/action.ts","../lib/collection.ts","../lib/subController.ts","../lib/storage.ts","../lib/collections/request.ts","../lib/collections/base.ts","../node_modules/@babel/runtime/helpers/typeof.js","../node_modules/@babel/runtime/helpers/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/setPrototypeOf.js","../lib/library.ts"],"sourcesContent":["export const protectedNames = [\n  'data',\n  'indexes',\n  'groups',\n  'computed',\n  'actions',\n  'routes'\n];\n\nexport const collectionFunctions = [\n  'collect',\n  'replaceIndex',\n  'getGroup',\n  'newGroup',\n  'deleteGroup',\n  'removeFromGroup',\n  'update',\n  'increment',\n  'decrement',\n  'delete',\n  'purge',\n  'watch',\n  'findById',\n  'put',\n  'move',\n  'throttle',\n  'forceUpdate',\n  // deprecated\n  'remove'\n];\n\nexport function defineConfig(config, defaults) {\n  return { ...defaults, ...config };\n}\n\nexport function parse(key: string) {\n  // if (typeof key !== 'string') debugger;\n  let primaryKey: string | number = key.split('/')[1];\n\n  let canBeNumber = Number(primaryKey);\n  if (canBeNumber !== NaN) primaryKey = canBeNumber;\n\n  return {\n    collection: key.split('/')[0],\n    primaryKey\n  };\n}\n\nexport function uuid() {\n  return (\n    Math.random()\n      .toString()\n      .split('.')[1] + Date.now()\n  );\n}\n\nexport function objectLoop(object, callback, keys?: Array<any>) {\n  const objectKeys = keys ? keys : Object.keys(object);\n  for (let i = 0; i < objectKeys.length; i++) {\n    const key: string = objectKeys[i];\n    const value: any = object[key];\n    callback(key, value, objectKeys);\n  }\n}\n\nexport function isWatchableObject(value) {\n  function isHTMLElement(obj) {\n    try {\n      return obj instanceof HTMLElement;\n    } catch (e) {\n      return (\n        typeof obj === 'object' &&\n        obj.nodeType === 1 &&\n        typeof obj.style === 'object' &&\n        typeof obj.ownerDocument === 'object'\n      );\n    }\n  }\n  let type = typeof value;\n  return (\n    value != null &&\n    type == 'object' &&\n    !isHTMLElement(value) &&\n    !Array.isArray(value)\n  );\n}\n\n// const thing = {}\n// objectLoop(thing, (thingKey, thingItem) => {\n\n// })\n\nexport function log(value: any, payload?: any) {\n  // console.log(`Pulse / ${value}`, payload ? payload : ' ');\n}\nexport function key(collection: string, property?: string | number) {\n  return `${collection}/${property}`;\n}\n\nexport function normalizeMap(map) {\n  return Array.isArray(map)\n    ? map.map(key => ({ key, val: key }))\n    : Object.keys(map).map(key => ({ key, val: map[key] }));\n}\n\nexport const arrayFunctions = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\nexport function cleanse(object: any) {\n  if (!isWatchableObject(object)) return object;\n  const clean = Object.assign({}, object);\n  const properties = Object.keys(clean);\n\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n\n    if (isWatchableObject(clean[property])) {\n      clean[property] = cleanse(clean[property]);\n    }\n  }\n  return clean;\n}\n\nexport function assert(\n  func: (warnings: { [key: string]: any }) => any,\n  funcName?: string\n) {\n  function warn(message) {\n    // if (funcName) console.log(`PULSE // \"${funcName}()\" :: ${message}`);\n    // else console.warn(`PULSE :: ${message}`);\n    return false;\n  }\n  const warnings = {\n    NO_PRIMARY_KEY: () => warn('No primary $1 key found! $2'),\n    INVALID_PARAMETER: () => warn('Invalid parameter supplied to function.'),\n    INDEX_NOT_FOUND: () => warn('Index was not found on collection.'),\n    INTERNAL_DATA_NOT_FOUND: () => warn('Data was not found on collection.'),\n    PROPERTY_NOT_A_NUMBER: () => warn('Property is not a number!')\n  };\n  return func(warnings)();\n}\n\nexport function validateNumber(mutable, amount) {\n  if (typeof amount !== 'number' || typeof mutable !== 'number') {\n    return false;\n  }\n  return true;\n}\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","var defineProperty = require(\"./defineProperty\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nmodule.exports = _objectSpread;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _extends() {\n  _extends =\n    Object.assign ||\n    function(target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n  return _extends.apply(this, arguments);\n}\n\nexport default function withPulse(pulse, React, ReactComponent, selectData) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        ...pulse.mapData(\n          selectData,\n          this,\n          {\n            waitForMount:\n              pulse._private.global.config.waitForMount === false ? false : true\n          },\n          pulse\n        )\n      };\n    }\n    componentDidMount() {\n      if (pulse._private.global.config.waitForMount) pulse.mount(this);\n    }\n    componentWillUnmount() {\n      if (pulse._private.global.config.autoUnmount) pulse.unmount(this);\n    }\n    render() {\n      return React.createElement(\n        ReactComponent,\n        _extends(\n          {\n            pulse: this.state\n          },\n          this.props\n        )\n      );\n    }\n  };\n}\n","import { Global } from './interfaces';\nimport { RelationTypes } from './relationController';\nimport { DynamicRelation } from './relationController2';\nimport Collection from './collection';\nexport default class Dep {\n  // these\n  public dependents: any = new Set();\n  public subscribers: Array<object> = [];\n\n  // these are temporary relations created by the relation controller\n  public dynamicRelation: DynamicRelation = null;\n\n  constructor(\n    private global: Global,\n    // if this dep is for public or internal data within a collection\n    public type: 'reactive' | 'internal' | 'index' = 'reactive',\n    // the name of the coll\n    public colleciton: Collection,\n    // either the name of the object if rective or the primaryKey if internal\n    public propertyName: string | number,\n    // if the dep is part of a deep reactive object, this is the root property name\n    public rootProperty: string = null\n  ) {}\n\n  // for when public data is accessed, reactive class will trigger this function\n  register() {\n    const subs = this.global.subs;\n\n    if (this.global.runningComputed) {\n      this.dependents.add(this.global.runningComputed);\n    }\n    if (this.global.runningPopulate) {\n      this.global.relations.relate(\n        this.global.runningPopulate as Dep,\n        this as Dep\n      );\n    }\n    if (subs.subscribingComponent) {\n      this.subscribeComponent();\n    }\n    if (subs.unsubscribingComponent) {\n      // this.subscribers.delete(this.global.subscribingComponent);\n    }\n  }\n\n  changed() {\n    this.global.relations.cleanup(this.dynamicRelation);\n  }\n\n  subscribeComponent() {\n    const subs = this.global.subs;\n\n    if (this.rootProperty && subs.skimmingDeepReactive) {\n      subs.prepareNext(this);\n      return;\n    }\n    if (this.rootProperty) {\n      subs.foundDeepReactive();\n      subs.prepareNext(this);\n      return;\n    }\n    if (!this.rootProperty && subs.skimmingDeepReactive) {\n      subs.exitDeepReactive();\n    }\n\n    this.subscribe();\n\n    subs.prepareNext(this);\n  }\n  subscribe() {\n    const subs = this.global.subs;\n    const keys = subs.subscribingComponent.keys;\n    const key = keys[subs.subscribingComponentKey];\n    const component = {\n      componentUUID: subs.subscribingComponent.componentUUID,\n      key: key\n    };\n    this.subscribers.push(component);\n  }\n}\n","import { Global } from './interfaces';\nimport { DynamicRelation } from './relationController2';\nexport default class Computed {\n  public relatedToGroup: Array<any> = [];\n  public dynamicRelation: DynamicRelation = null;\n\n  constructor(\n    private global: Global,\n    public collection: string,\n    public name: string,\n    private computedFunction: (context: object) => any\n  ) {}\n\n  public run() {\n    this.global.relations.cleanup(this.dynamicRelation);\n\n    this.global.runningComputed = this;\n\n    let output = this.computedFunction(this.global.getContext(this.collection));\n\n    if (output === undefined || output === null) output = false;\n\n    this.global.runningComputed = false;\n    // haha uh oh stinky\n    return output;\n  }\n}\n// This is luka's log no. 197234 It's been 12 years, i dtil dont know the source of magnetic pull. why do rocks like stick together.. like wtf bro. for real how the fuck do magnets work\n","import { Global } from './interfaces';\nimport Computed from './computed';\nimport Dep from './dep';\n\nexport class DynamicRelation {\n  public depsToClean: Set<Dep> = new Set();\n  constructor(public updateThis: Dep | Computed) {}\n\n  // perform cleanup of all refrences to this instance\n  public destroy() {\n    this.depsToClean.forEach(dep => dep.dependents.delete(this));\n    delete this.updateThis.dynamicRelation;\n  }\n}\n\nexport default class RelationController {\n  private relationBank: Set<DynamicRelation> = new Set();\n\n  constructor(private global: Global) {}\n\n  // function called during runningComputed and runningPopulate\n  public relate(updateThis: Computed | Dep, whenDepChanges: Dep) {\n    if (!whenDepChanges) return; // if a dep is not found, abort\n    let dep = whenDepChanges;\n\n    if (!updateThis.dynamicRelation) {\n      updateThis.dynamicRelation = new DynamicRelation(updateThis);\n      this.relationBank.add(updateThis.dynamicRelation);\n    }\n\n    // save Dep inside relation so relation knows where to remove dependent from on cleanup\n    updateThis.dynamicRelation.depsToClean.add(dep);\n\n    // add dynamic relation as a dependent inside Dep\n    dep.dependents.add(updateThis.dynamicRelation);\n  }\n\n  // when a job is complete with a dep that includes a dynamic\n  public cleanup(dynamicRelation: DynamicRelation): void {\n    // perform cleanup, destroy dynamic relation\n    if (!dynamicRelation) return;\n    dynamicRelation.destroy(); // destory all refrences\n    this.relationBank.delete(dynamicRelation); // remove last reference from bank\n  }\n}\n\nexport enum RelationTypes {\n  COMPUTED_DEPENDS_ON_DATA = 'COMPUTED_DEPENDS_ON_DATA', // used by findById() when run in computed\n  COMPUTED_DEPENDS_ON_GROUP = 'COMPUTED_DEPENDS_ON_GROUP', // used by getGroup() when run in computed\n  DATA_DEPENDS_ON_DEP = 'DATA_DEPENDS_ON_DEP', // the Dep class of a property when used in populate()\n  DATA_DEPENDS_ON_GROUP = 'DATA_DEPENDS_ON_GROUP', // used by getGroup() when run in populate()\n  DATA_DEPENDS_ON_DATA = 'DATA_DEPENDS_ON_DATA' // used by findById() when run in populate()\n}\n","import { log, objectLoop, log, cleanse } from './helpers';\nimport { Job, Global } from './interfaces';\nimport Dep from './Dep';\nimport Computed from './computed';\nimport { DynamicRelation } from './relationController';\n\nexport enum JobType {\n  PUBLIC_DATA_MUTATION = 'PUBLIC_DATA_MUTATION',\n  INTERNAL_DATA_MUTATION = 'INTERNAL_DATA_MUTATION',\n  INDEX_UPDATE = 'INDEX_UPDATE',\n  COMPUTED_REGEN = 'COMPUTED_REGEN',\n  GROUP_UPDATE = 'GROUP_UPDATE',\n  SOFT_GROUP_UPDATE = 'SOFT_GROUP_UPDATE',\n  DELETE_INTERNAL_DATA = 'DELETE_INTERNAL_DATA'\n}\nexport default class Runtime {\n  public running: Boolean = false;\n  public updatingSubscribers: Boolean = false;\n\n  private ingestQueue: Array<Job> = [];\n  private completedJobs: Array<Job> = [];\n  private archivedJobs: Array<Job> = [];\n\n  // private collections: Object;\n  private config: Object;\n\n  constructor(private collections: Object, private global: Global) {\n    global.ingest = this.ingest.bind(this);\n    global.ingestDependents = this.ingestDependents.bind(this);\n    this.config = global.config;\n  }\n\n  // The primary entry point for Runtime, all jobs should come through here\n  public ingest(job: Job): void {\n    // console.log(job);\n    this.ingestQueue.push(job);\n\n    // don't begin the next job until this one is fully complete\n    if (!this.running) {\n      this.findNextJob();\n    }\n  }\n\n  private findNextJob() {\n    this.running = true;\n    // shift the next job from the queue\n    let next = this.ingestQueue.shift();\n\n    if (!next.dep && next.type !== JobType.INDEX_UPDATE)\n      // groups, computed and indexes will not have their Dep class, so get it.\n      next.dep = this.global.getDep(next.property, next.collection);\n\n    // execute the next task in the queue\n    this.performJob(next);\n  }\n\n  private performJob(job: Job): void {\n    switch (job.type) {\n      case JobType.PUBLIC_DATA_MUTATION:\n        this.performPublicDataUpdate(job);\n        this.collections[job.collection].runWatchers(job.property);\n        break;\n      case JobType.INTERNAL_DATA_MUTATION:\n        this.performInternalDataUpdate(job);\n        break;\n      case JobType.INDEX_UPDATE:\n        this.performIndexUpdate(job);\n        break;\n      case JobType.COMPUTED_REGEN:\n        this.performComputedOutput(job);\n        this.collections[job.collection].runWatchers(job.property.name);\n        break;\n      case JobType.GROUP_UPDATE:\n        this.performGroupRebuild(job);\n        this.collections[job.collection].runWatchers(job.property);\n        break;\n      case JobType.SOFT_GROUP_UPDATE:\n        this.performGroupRebuild(job);\n        this.collections[job.collection].runWatchers(job.property);\n        break;\n      case JobType.DELETE_INTERNAL_DATA:\n        this.performInternalDataDeletion(job);\n        break;\n      default:\n        break;\n    }\n\n    // unpack dependents\n    if (job.dep && job.dep.dependents.size > 0) {\n      this.ingestDependents(job.dep.dependents);\n    }\n\n    this.finished();\n  }\n\n  public ingestDependents(dependents: Set<any>): void {\n    // this is called twice below\n    const ingestComputed = (computed: Computed) =>\n      this.ingest({\n        type: JobType.COMPUTED_REGEN,\n        collection: computed.collection,\n        property: computed,\n        dep: this.global.getDep(computed.name, computed.collection)\n      });\n\n    // for each dependent stored in dep class\n    dependents.forEach(dependent => {\n      // there are two types of dependents stored: Computed and DynamicRelation\n      if (dependent instanceof Computed) ingestComputed(dependent);\n      else if (dependent instanceof DynamicRelation) {\n        // one might think using \"instanceOf\" would work as expected below\n        // but it doesn't, alas I hate javascript.\n        // temp fix: constructor.name - be my guest try and fix this??\n        const type = dependent.updateThis.constructor.name;\n        // DynamicRelation can store either Computed or Dep (internal)\n        if (type === Computed.name)\n          ingestComputed(dependent.updateThis as Computed);\n        else if (type === Dep.name) {\n          // ingest internal data mutation without a value will result in a soft group update\n          this.ingest({\n            type: JobType.INTERNAL_DATA_MUTATION,\n            collection: (dependent.updateThis as Dep).colleciton.name,\n            property: (dependent.updateThis as Dep).propertyName\n          });\n        }\n      }\n    });\n  }\n\n  // handle job loop flow\n  private finished(): void {\n    this.running = false;\n    if (this.completedJobs.length > 5000) return;\n\n    // If there's already more stuff in the queue, loop.\n    if (this.ingestQueue.length > 0) {\n      this.findNextJob();\n      return;\n    }\n\n    // Wait until callstack is empty to check if we should finalise this body of work\n    setTimeout(() => {\n      if (this.ingestQueue.length === 0) {\n        if (!this.updatingSubscribers) this.compileComponentUpdates();\n        this.cleanup();\n      } else {\n        // loop more!\n        this.findNextJob();\n      }\n    });\n  }\n\n  // ****************** Perform Functions ****************** //\n  private performPublicDataUpdate(job: Job): void {\n    this.writeToPublicObject(job.collection, 'data', job.property, job.value);\n    this.completedJob(job);\n  }\n\n  private performInternalDataUpdate(job: Job): void {\n    // if job was not ingested with a value, get the most recent value from collection database\n    if (!job.value) {\n      if (this.collections[job.collection].internalData[job.property])\n        job.value = this.collections[job.collection].internalData[job.property];\n      // this would usually be redundant, since the data has not changed, but since the relationController has no access to the collections, but does need to trigger data to rebuild, it issues an internal data \"update\". It's own data has not changed, but the dynamic data related to it via populate() has.\n    }\n\n    // overwrite or insert the data into collection database saving the previous value to job.previousValue, since this.overwriteInternalData returns it.\n    job.previousValue = this.overwriteInternalData(\n      job.collection,\n      job.property as string | number,\n      job.value\n    );\n\n    // collection function handels ingesting indexes to update itself, since it waits until\n    // all internal data has been ingested before handling the affected indexes\n    // however for direct data modifications we should update afected indexes\n    if (!this.global.collecting) {\n      // affected indexes is an array of indexes that have this primary key (job.property) present.\n      const affectedIndexes: Array<string> = this.collections[\n        job.collection\n      ].searchIndexesForPrimaryKey(job.property);\n\n      affectedIndexes.forEach(index => {\n        // since this is a singular piece of data that has changed, we do not need to\n        // rebuild the entire group, so we can soft rebuild\n        let modifiedGroup = this.collections[\n          job.collection\n        ].softUpdateGroupData(job.property, index);\n\n        this.ingest({\n          type: JobType.SOFT_GROUP_UPDATE,\n          collection: job.collection,\n          value: modifiedGroup,\n          property: index,\n          dep: this.global.getDep(index, job.collection)\n          // we do not need a previousValue because groups are cached outputs and reversing the internal data update will do the trick\n        });\n      });\n    }\n\n    this.completedJob(job);\n  }\n\n  private performInternalDataDeletion(job: Job): void {\n    const c = this.collections[job.collection];\n    // preserve previous value\n    job.previousValue = { ...c.internalData[job.property] };\n    // delete data\n    delete c.internalData[job.property];\n    // find indexes affected by this data deletion\n    const indexesToUpdate = this.collections[\n      job.collection\n    ].searchIndexesForPrimaryKey(job.collection, job.property);\n\n    // for each found index, perform index update\n    for (let i = 0; i < indexesToUpdate.length; i++) {\n      const indexName = indexesToUpdate[i];\n      const newIndex = [...c.indexes.object[indexName]].filter(\n        id => id !== job.property\n      );\n      this.ingest({\n        type: JobType.INDEX_UPDATE,\n        collection: c.name,\n        property: indexName,\n        value: newIndex,\n        dep: this.global.getDep(job.property, job.collection)\n      });\n    }\n    this.completedJob(job);\n  }\n\n  private performIndexUpdate(job: Job): void {\n    // preserve old index\n    job.previousValue = this.collections[job.collection].indexes[job.property];\n    // Update Index\n    this.collections[job.collection].indexes.privateWrite(\n      job.property,\n      job.value\n    );\n    this.completedJob(job);\n\n    // Group must also be updated\n    this.ingest({\n      type: JobType.GROUP_UPDATE,\n      collection: job.collection,\n      property: job.property,\n      dep: this.global.getDep(job.property, job.collection)\n    });\n  }\n\n  private performGroupRebuild(job: Job): void {\n    // soft group rebuilds already have a generated value, otherwise generate the value\n    if (!job.value) {\n      job.value = this.collections[job.collection].buildGroupFromIndex(\n        job.property\n      );\n    }\n\n    // TODO: trigger relaction controller to update group relations\n    // this.global.relations.groupModified(job.collection, job.property);\n\n    this.writeToPublicObject(job.collection, 'group', job.property, job.value);\n    this.completedJob(job);\n  }\n\n  public performComputedOutput(job: Job): void {\n    const computed =\n      typeof job.property === 'string'\n        ? this.collections[job.collection].computed[job.property]\n        : job.property;\n\n    job.value = computed.run();\n    // Commit Update\n    this.writeToPublicObject(\n      job.collection,\n      'computed',\n      computed.name,\n      job.value\n    );\n    this.completedJob(job);\n  }\n\n  // ****************** Handlers ****************** //\n\n  private completedJob(job: Job): void {\n    // if action is running, save that action instance inside job payload\n    job.fromAction = this.global.runningAction;\n    // during runtime log completed job ready for component updates\n    if (this.global.initComplete) this.completedJobs.push(job);\n    // if data is persistable ensure storage is updated with new data\n    this.persistData(job);\n\n    // tell the dep the parent changed\n    if (job.dep) job.dep.changed();\n  }\n\n  // ****************** End Runtime Events ****************** //\n\n  private compileComponentUpdates(): void {\n    if (!this.global.initComplete) return;\n    this.updatingSubscribers = true;\n    log('ALL JOBS COMPLETE', this.completedJobs);\n    log('Updating components...');\n\n    const componentsToUpdate = {};\n\n    // for all completed jobs\n    for (let i = 0; i < this.completedJobs.length; i++) {\n      const job = this.completedJobs[i];\n\n      // if job has a Dep class present\n      // Dep class contains subscribers to that property (as a completed job)\n      if (job.dep) {\n        let subscribers: Array<any> = job.dep.subscribers;\n\n        // for all the subscribers\n        for (let i = 0; i < subscribers.length; i++) {\n          // add to componentsToUpdate (ensuring update & component is unique)\n          const uuid = subscribers[i].componentUUID;\n          const key = subscribers[i].key;\n          // below is a band-aid, caused by (what I believe to be) deep reactive properties submitting several updates for the same mutation, one for each level deep, since the parent is triggered as well\n          // if (!key) continue;\n\n          // if this component isn't already registered for this particular update, add it.\n          if (!componentsToUpdate[uuid]) {\n            componentsToUpdate[uuid] = {};\n            componentsToUpdate[uuid][key] = job.value;\n            // otherwise add the update to the component\n          } else {\n            componentsToUpdate[uuid][key] = job.value;\n          }\n        }\n      }\n    }\n\n    this.updateSubscribers(componentsToUpdate);\n    this.completedJobs = [];\n  }\n\n  private updateSubscribers(componentsToUpdate) {\n    // console.log('updating subscribers', componentsToUpdate);\n    const componentKeys = Object.keys(componentsToUpdate);\n    for (let i = 0; i < componentKeys.length; i++) {\n      const componentID = componentKeys[i];\n      const componentInstance = this.global.subs.componentStore[componentID];\n      if (!componentInstance || !componentInstance.instance) return;\n      const propertiesToUpdate = componentsToUpdate[componentID];\n      const dataKeys = Object.keys(propertiesToUpdate);\n      // Switch depending on framework\n\n      switch (this.global.config.framework) {\n        case 'vue':\n          dataKeys.forEach(property => {\n            const value = propertiesToUpdate[property];\n            componentInstance.instance.$set(\n              componentInstance.instance,\n              property,\n              // this prevents vue from adding getters/setters to any objects, but might be wasteful computation\n              // considering this is not important and does not change perfomance, its probably best to not bother cleansing every\n              // value update. actually thinking about it this is terrbile. remove this soon.\n              // honestly it's only here because I have OCD.\n              cleanse(value)\n            );\n          });\n          break;\n        case 'react':\n          componentInstance.instance.setState(propertiesToUpdate);\n          // console.log(propertiesToUpdate);\n          break;\n\n        default:\n          break;\n      }\n    }\n  }\n\n  private persistData(job: Job): void {\n    if (job.type === JobType.INTERNAL_DATA_MUTATION) return;\n    if (this.collections[job.collection].persist.includes(job.property)) {\n      this.global.storage.set(job.collection, job.property, job.value);\n    }\n  }\n\n  private cleanup(): void {\n    setTimeout(() => {\n      this.updatingSubscribers = false;\n    });\n  }\n\n  // ****************** Misc Handlers ****************** //\n\n  private writeToPublicObject(\n    collection: string,\n    type: string,\n    key: string,\n    value: any\n  ): void {\n    if (type === 'indexes') {\n      if (!this.collections[collection][type].object.hasOwnProperty(key))\n        return;\n      this.collections[collection][type].privateWrite(key, value);\n    } else {\n      if (!this.collections[collection].public.object.hasOwnProperty(key))\n        return;\n      this.collections[collection].public.privateWrite(key, value);\n    }\n  }\n\n  private overwriteInternalData(\n    collection: string,\n    primaryKey: string | number,\n    newData: any\n  ): object | boolean {\n    const internalData = this.collections[collection].internalData;\n    // create a copy of the original data\n    const currentData = internalData[primaryKey]\n      ? { ...internalData[primaryKey] }\n      : false;\n\n    if (currentData) {\n      // data already exists, merge objects and return previous object\n      const keys = Object.keys(newData || {});\n      for (let i = 0; i < keys.length; i++) {\n        const property = keys[i];\n        internalData[primaryKey][property] = newData[property];\n      }\n      return currentData;\n    } else {\n      // data does not exist, write and return false\n      internalData[primaryKey] = newData;\n      return false;\n    }\n  }\n}\n","import { Global } from './interfaces';\nimport { RelationTypes } from './relationController';\nimport { DynamicRelation } from './relationController2';\nimport Collection from './collection';\nexport default class Dep {\n  // these\n  public dependents: any = new Set();\n  public subscribers: Array<object> = [];\n\n  // these are temporary relations created by the relation controller\n  public dynamicRelation: DynamicRelation = null;\n\n  constructor(\n    private global: Global,\n    // if this dep is for public or internal data within a collection\n    public type: 'reactive' | 'internal' | 'index' = 'reactive',\n    // the name of the coll\n    public colleciton: Collection,\n    // either the name of the object if rective or the primaryKey if internal\n    public propertyName: string | number,\n    // if the dep is part of a deep reactive object, this is the root property name\n    public rootProperty: string = null\n  ) {}\n\n  // for when public data is accessed, reactive class will trigger this function\n  register() {\n    const subs = this.global.subs;\n\n    if (this.global.runningComputed) {\n      this.dependents.add(this.global.runningComputed);\n    }\n    if (this.global.runningPopulate) {\n      this.global.relations.relate(\n        this.global.runningPopulate as Dep,\n        this as Dep\n      );\n    }\n    if (subs.subscribingComponent) {\n      this.subscribeComponent();\n    }\n    if (subs.unsubscribingComponent) {\n      // this.subscribers.delete(this.global.subscribingComponent);\n    }\n  }\n\n  changed() {\n    this.global.relations.cleanup(this.dynamicRelation);\n  }\n\n  subscribeComponent() {\n    const subs = this.global.subs;\n\n    if (this.rootProperty && subs.skimmingDeepReactive) {\n      subs.prepareNext(this);\n      return;\n    }\n    if (this.rootProperty) {\n      subs.foundDeepReactive();\n      subs.prepareNext(this);\n      return;\n    }\n    if (!this.rootProperty && subs.skimmingDeepReactive) {\n      subs.exitDeepReactive();\n    }\n\n    this.subscribe();\n\n    subs.prepareNext(this);\n  }\n  subscribe() {\n    const subs = this.global.subs;\n    const keys = subs.subscribingComponent.keys;\n    const key = keys[subs.subscribingComponentKey];\n    const component = {\n      componentUUID: subs.subscribingComponent.componentUUID,\n      key: key\n    };\n    this.subscribers.push(component);\n  }\n}\n","import { protectedNames, arrayFunctions, isWatchableObject } from './helpers';\nimport Dep from './dep';\nimport { Global } from './interfaces';\nimport Collection from './collection';\n\ninterface Obj {\n  [key: string]: any;\n}\n\nexport default class Reactive {\n  public properties: Array<string>;\n  public object: Obj;\n  private dispatch: any;\n  private allowPrivateWrite: boolean = false;\n  private touching: boolean = false;\n  private touched: null | Dep;\n  private sneaky: boolean;\n  private tempDeps: { [key: string]: Dep } = {};\n\n  constructor(\n    object: Obj = {},\n    private global: Global,\n    private collection: Collection,\n    public mutable: Array<string>,\n    public type: 'root' | 'indexes'\n  ) {\n    this.dispatch = this.global.dispatch;\n    this.properties = Object.keys(object);\n\n    this.object = this.reactiveObject(object);\n  }\n\n  reactiveObject(object: Obj, rootProperty?: string): object {\n    const objectKeys = Object.keys(object);\n\n    // Loop over all properties of the to-be reactive object\n    for (let i = 0; i < objectKeys.length; i++) {\n      const key = objectKeys[i];\n      this.defineProperty(object, key, rootProperty);\n    }\n    return object;\n  }\n\n  private defineProperty(\n    object: Obj,\n    key: string,\n    rootProperty?: string\n  ): object {\n    const self = this;\n    let value = object[key];\n    if (object.rootProperty) rootProperty = object.rootProperty;\n\n    // // If property is an array, make it reactive\n    // if (Array.isArray(value)) {\n    //   // value = this.reactiveArray(value, key);\n    // }\n\n    // rootProperty should be the current key if first deep object\n    if (isWatchableObject(value) && !protectedNames.includes(key)) {\n      value = this.deepReactiveObject(value, rootProperty || key, key);\n    }\n\n    // Create an instance of the dependency tracker\n    const dep = this.createDep(key, rootProperty);\n\n    Object.defineProperty(object, key, {\n      get: function pulseGetter() {\n        if (self.sneaky) return value;\n\n        if (self.global.touching) {\n          self.global.touched = dep;\n          return value;\n        }\n        dep.register();\n\n        return value;\n      },\n      set: function pulseSetter(newValue) {\n        // DEEP REACTIVE handler: \"rootProperty\" indicates if the object is \"deep\".\n        if (rootProperty && self.mutable.includes(rootProperty)) {\n          // mutate locally\n          value = newValue;\n          // dispatch mutation for deep property\n          self.dispatch('mutation', {\n            collection: self.collection.name,\n            key: rootProperty,\n            value: self.object[rootProperty],\n            dep\n          });\n\n          // Regular muations\n        } else {\n          // if a protected name allow direct mutation\n          if (protectedNames.includes(key)) {\n            return (value = newValue);\n          }\n          // if backdoor open allow direct mutation\n          if (self.allowPrivateWrite) {\n            // dynamically convert new values to reactive if objects\n            // This is risky as fuck and kinda doesn't even work\n            if (isWatchableObject(value) && self.mutable.includes(key)) {\n              // debugger;\n              newValue = self.deepReactiveObject(\n                newValue,\n                rootProperty || key,\n                key\n              );\n            }\n            return (value = newValue);\n          }\n\n          // if property is mutable dispatch update\n          if (self.mutable.includes(key)) {\n            self.dispatch('mutation', {\n              collection: self.collection.name,\n              key,\n              value: newValue,\n              dep\n            });\n            // we did not apply the mutation since runtime will privatly\n            // write the result since we dispatched above\n          }\n        }\n      }\n    });\n    return object;\n  }\n\n  public addProperty(key, value) {\n    this.object[key] = value;\n    this.defineProperty(this.object, key);\n  }\n\n  public tempDep(property) {\n    const dep = this.createDep(property);\n    this.tempDeps[property] = dep;\n    return dep;\n  }\n\n  private cloneDep(dep: Dep) {\n    dep = Object.assign(Object.create(Object.getPrototypeOf(dep)), dep);\n    // debugger;\n    // delete this.tempDeps[dep.propertyName];\n    return dep;\n  }\n\n  private createDep(key: string, rootProperty?: string) {\n    let dep: Dep;\n    if (this.tempDeps.hasOwnProperty(key) && !rootProperty) {\n      dep = this.cloneDep(this.tempDeps[key]);\n    } else {\n      dep = new Dep(\n        this.global,\n        this.type === 'indexes' ? 'index' : 'reactive',\n        this.collection,\n        key,\n        rootProperty\n      );\n    }\n    return dep;\n  }\n\n  private deepReactiveObject(\n    value,\n    rootProperty?: string,\n    propertyName?: string\n  ) {\n    let objectWithCustomPrototype = Object.create({\n      rootProperty,\n      propertyName\n    });\n\n    // repopulate custom object with incoming values\n    const keys = Object.keys(value);\n    for (let i = 0; i < keys.length; i++) {\n      const property = keys[i];\n      objectWithCustomPrototype[property] = value[property];\n    }\n\n    this.allowPrivateWrite = true;\n    const obj = this.reactiveObject(objectWithCustomPrototype, rootProperty);\n    this.allowPrivateWrite = false;\n    return obj;\n  }\n\n  reactiveArray(array, key) {\n    const self = this;\n    const reactiveArray = array.slice();\n\n    for (let i = 0; i < arrayFunctions.length; i++) {\n      const func = arrayFunctions[i];\n      const original = Array.prototype[func];\n      Object.defineProperty(reactiveArray, func, {\n        value: function() {\n          const result = original.apply(this, arguments);\n          if (self.global.initComplete)\n            self.dispatch('mutation', {\n              collection: self.collection.name,\n              key,\n              value: result\n            });\n          return result;\n        }\n      });\n    }\n    return reactiveArray;\n  }\n\n  public privateWrite(property, value) {\n    this.allowPrivateWrite = true;\n    this.object[property] = value;\n    this.allowPrivateWrite = false;\n  }\n\n  // sneaky blocked the getter, sneaky.\n  public privateGet(property) {\n    this.sneaky = true;\n    const data = this.object[property];\n    this.sneaky = false;\n    return data;\n  }\n\n  public exists(property: string): boolean {\n    this.sneaky = true;\n    const bool = !!this.object.hasOwnProperty(property);\n    this.sneaky = false;\n    return bool;\n  }\n\n  public getKeys(): Array<string> {\n    this.sneaky = true;\n    const keys = Object.keys(this.object);\n    this.sneaky = false;\n    return keys;\n  }\n}\n\n// look for computed output access to determine dependencies\n// remove computed categories from public object on default config\n","import { uuid } from \"./helpers\";\nimport { Global } from \"./interfaces\";\n\nexport default class Action {\n  public executing: boolean = false;\n  public uuid: string;\n  public exec: () => {};\n\n  constructor(\n    private collection: string,\n    private global: Global,\n    public action: any,\n    public actionName: string\n  ) {\n    this.uuid = uuid();\n    this.prepare(action, global, this.global.contextRef.undo);\n  }\n\n  prepare(action, global, undo) {\n    const _this = this;\n\n    this.exec = function() {\n      const context = global.getContext(_this.collection);\n      context.undo = error => {\n        return undo(this.actionName, this.uuid, error);\n      };\n      global.runningAction = _this;\n\n      _this.executing = true;\n\n      const result = action.apply(\n        null,\n        [context].concat(Array.prototype.slice.call(arguments))\n      );\n\n      _this.executing = false;\n      global.runningAction = false;\n\n      return result;\n    };\n  }\n}\n","import {\n  assert,\n  defineConfig,\n  validateNumber,\n  collectionFunctions,\n  objectLoop,\n  key\n} from './helpers';\nimport Reactive from './reactive';\nimport Action from './action';\nimport Computed from './computed';\nimport Dep from './dep';\nimport { JobType } from './runtime';\nimport {\n  Methods,\n  Keys,\n  CollectionObject,\n  CollectionConfig,\n  Global,\n  ExpandableObject\n} from './interfaces';\nimport { RelationTypes, Key } from './relationController';\n\nexport default class Collection {\n  private namespace: CollectionObject;\n  public public: Reactive;\n  public indexes: Reactive;\n  public config: CollectionConfig = {};\n  public keys: Keys = {};\n  public methods: Methods = {};\n\n  public actions: { [key: string]: Action } = {};\n  public computed: { [key: string]: Computed } = {};\n  public watchers: { [key: string]: any } = {};\n  public externalWatchers: { [key: string]: any } = {};\n  public persist: Array<string> = [];\n  public local: { [key: string]: any } = {};\n  public model: { [key: string]: any } = {};\n\n  public collectionSize: number = 0;\n  public primaryKey: string | number | boolean = false;\n\n  private internalData: object = {};\n  public internalDataDeps: object = {}; // this contains the dep classes for all internal data\n  private internalDataWithPopulate: Array<string> = [];\n\n  dispatch: void;\n\n  constructor(\n    public name: string,\n    protected global: Global,\n    root: CollectionObject\n  ) {\n    this.config = root.config;\n    this.dispatch = this.global.dispatch;\n\n    // legacy support (\"filters\" changed to \"computed\")\n    root.computed = { ...root.computed, ...root.filters };\n\n    root = this.prepareNamespace(root);\n\n    this.initReactive(root.data, root.groups);\n    this.initRoutes(root.routes);\n    this.initActions(root.actions);\n    this.initWatchers(root.watch);\n    this.initComputed(root.computed);\n\n    this.initModel(root.model);\n    this.initPersist(root.persist);\n  }\n\n  prepareNamespace(root: CollectionObject) {\n    // map collection methods\n    collectionFunctions.map(\n      func => (this.methods[func] = this[func].bind(this))\n    );\n\n    if (root.local) this.local = root.local;\n\n    // for each type set default and register keys\n    ['data', 'actions', 'computed', 'indexes', 'routes', 'watch'].forEach(\n      type => {\n        if (type !== 'indexes' && !root[type]) root[type] = {};\n        this.keys[type] =\n          type === 'indexes' ? root['groups'] || [] : Object.keys(root[type]);\n      }\n    );\n\n    // assign namespace, this is used by initReactive\n    this.namespace = Object.assign(\n      Object.create({ ...this.methods }), // bind methods to prototype\n      {\n        routes: {},\n        indexes: {},\n        actions: root.actions,\n        ...root.computed,\n        ...root.data,\n        ...this.normalizeGroups(root.groups)\n      }\n    );\n    return root;\n  }\n\n  // groups are defined by the user as an array of strings, this converts them into object/keys\n  normalizeGroups(groupsAsArray: any = []) {\n    const groups: object = {};\n    for (let i = 0; i < groupsAsArray.length; i++) {\n      const groupName = groupsAsArray[i];\n      groups[groupName] = [];\n    }\n    return groups;\n  }\n\n  runWatchers(property) {\n    const watcher = this.watchers[property];\n    if (watcher) watcher();\n    const externalWatchers = this.externalWatchers[property];\n    if (externalWatchers)\n      externalWatchers.forEach(func =>\n        typeof func === 'function' ? func() : false\n      );\n  }\n\n  initReactive(data: object = {}, groups: Array<any> | object = []) {\n    groups = this.normalizeGroups(groups);\n    // Make indexes reactive\n    this.indexes = new Reactive(\n      groups, // object\n      this.global, // global\n      this, // collection\n      this.keys.indexes, // mutable\n      'indexes' // type\n    );\n    this.namespace.indexes = this.indexes.object;\n\n    // Make entire public object Reactive\n    this.public = new Reactive(\n      this.namespace,\n      this.global,\n      this,\n      [...this.keys.data, ...this.keys.indexes],\n      'root'\n    );\n  }\n\n  initPersist(persist: Array<string>): void {\n    if (!Array.isArray(persist)) return;\n\n    for (let i = 0; i < persist.length; i++) {\n      const dataName = persist[i];\n\n      // TODO: validate\n\n      this.persist.push(dataName);\n      if (this.global.storage.isPromise) {\n        this.global.storage.get(this.name, dataName).then(data => {\n          if (data === undefined || data === null) return;\n          const job = {\n            type: JobType.PUBLIC_DATA_MUTATION,\n            value: data,\n            property: dataName,\n            collection: this.name,\n            dep: this.global.getDep(dataName, this.name)\n          };\n          this.global.ingest(job);\n        });\n      } else {\n        let data = this.global.storage.get(this.name, dataName);\n        if (data === undefined || data === null) continue;\n        this.public.privateWrite(dataName, data);\n      }\n    }\n  }\n\n  initActions(actions: object = {}) {\n    let actionKeys = Object.keys(actions);\n    for (let i = 0; i < actionKeys.length; i++) {\n      const action = actions[actionKeys[i]];\n      this.actions[actionKeys[i]] = new Action(\n        this.name,\n        this.global,\n        action,\n        actionKeys[i]\n      );\n\n      this.public.privateWrite(actionKeys[i], this.actions[actionKeys[i]].exec);\n    }\n  }\n\n  initWatchers(watchers: object = {}) {\n    let watcherKeys = Object.keys(watchers);\n    for (let i = 0; i < watcherKeys.length; i++) {\n      const watcher = watchers[watcherKeys[i]];\n      this.watchers[watcherKeys[i]] = () => {\n        this.global.runningWatcher = {\n          collection: this.name,\n          property: watcherKeys[i]\n        };\n        const watcherOutput = watcher(this.global.getContext(this.name));\n        this.global.runningWatcher = false;\n        return watcherOutput;\n      };\n    }\n    this.watchers._keys = watcherKeys;\n  }\n\n  initComputed(computed: object): void {\n    objectLoop(\n      computed,\n      (computedName: string, computedFunction: () => void) => {\n        this.computed[computedName] = new Computed(\n          this.global,\n          this.name,\n          computedName,\n          computedFunction\n        );\n        this.public.object[computedName] = [];\n      },\n      this.keys.computed\n    );\n  }\n\n  initRoutes(routes: ExpandableObject) {\n    const self = this;\n    const routeWrapped = routeName => {\n      return function() {\n        let requestObject = Object.assign({}, self.global.request);\n        requestObject.context = self.global.getContext();\n        return routes[routeName].apply(\n          null,\n          [requestObject].concat(Array.prototype.slice.call(arguments))\n        );\n      };\n    };\n    objectLoop(\n      routes,\n      routeName =>\n        (this.public.object.routes[routeName] = routeWrapped(routeName))\n    );\n  }\n\n  initModel(model = {}) {\n    this.model = model;\n    Object.keys(model).forEach(property => {\n      Object.keys(model[property]).forEach(config => {\n        switch (config) {\n          case 'primaryKey':\n            this.primaryKey = property;\n            break;\n          case 'populate':\n            this.internalDataWithPopulate.push(property);\n            break;\n        }\n      });\n    });\n  }\n\n  private getData(id) {\n    return { ...this.internalData[id] };\n  }\n\n  public buildGroupFromIndex(groupName: string): Array<number> {\n    const constructedArray = [];\n    // get index directly\n    let index = this.indexes.privateGet(groupName);\n    if (!index) return [];\n\n    // for every primaryKey in the index\n    for (let i = 0; i < index.length; i++) {\n      // primaryKey of data\n      let id = index[i];\n      // copy data from internal database\n      let data = this.getData(id);\n      // if none found skip\n      if (!data) continue;\n      // inject dynamic data\n      data = this.injectDynamicRelatedData(id, data);\n\n      constructedArray.push(data);\n    }\n    return constructedArray;\n  }\n\n  // rebuilding an entire group is expensive on resources, but is\n  // not nessisary if only one piece of data has changed\n  // this function will replace a single piece of data without rebuilding\n  // the entire group\n  public softUpdateGroupData(\n    primaryKey: string | number,\n    groupName: string\n  ): Array<any> {\n    let index: Array<any> = this.indexes.privateGet(groupName);\n\n    // find the data's position within index\n    let position: number = index.indexOf(primaryKey);\n\n    // if group is dynamic, just build the group from index.\n    if (!this.public[groupName]) return this.buildGroupFromIndex(groupName);\n\n    // copy the current group output\n    let currentGroup: Array<any> = [this.public[groupName]];\n\n    // get data for primaryKey\n    let data: { [key: string]: any } = { ...this.internalData[primaryKey] };\n\n    data = this.injectDynamicRelatedData(primaryKey, data);\n\n    // replace at known position with updated data\n    currentGroup[position] = data;\n\n    return currentGroup;\n  }\n\n  // This should be called on every piece of data retrieved when building a group from an index\n  private injectDynamicRelatedData(\n    primaryKey: string | number,\n    data: { [key: string]: any }\n  ): any {\n    // for each populate function extracted from the model for this data\n    this.internalDataWithPopulate.forEach(property => {\n      const dep = this.global.getDep(primaryKey, this.name, true);\n      this.global.runningPopulate = dep;\n      // run populate function passing in the context and the data\n      const populated = this.model[property].populate(\n        this.global.getContext(),\n        data\n      );\n\n      this.global.runningPopulate = false;\n      // inject result to data\n      data[property] = populated;\n    });\n    return data;\n  }\n\n  public createGroups(group) {\n    if (group === undefined) group = [];\n    else if (!Array.isArray(group)) group = [group];\n\n    for (let i = 0; i < group.length; i++) {\n      const groupName = group[i];\n      if (!this.indexes.exists(groupName)) {\n        this.indexes.addProperty(groupName, []);\n        // this.indexes.privateWrite(groupName, []);\n      }\n    }\n    return group;\n  }\n\n  // METHODS\n\n  public collect(\n    data,\n    group?: string | Array<string>,\n    config?: ExpandableObject\n  ) {\n    config = defineConfig(config, {\n      append: true\n    });\n    this.global.collecting = true;\n    // normalise data\n    if (!Array.isArray(data)) data = [data];\n\n    // if groups don't already exist, create them dynamically\n    const groups: Array<string> = this.createGroups(group);\n    // groups now contains just the groups directly modified by this collect\n\n    // preserve index previous values\n    const previousIndexValues: object = this.getPreviousIndexValues(groups);\n\n    const indexesToRegenOnceComplete = new Set();\n\n    // process data items\n    for (let i = 0; i < data.length; i++) {\n      const dataItem = data[i];\n\n      if (dataItem === null) continue;\n      // process data item returns \"success\" as a boolean and affectedIndexes as an array\n      const processDataItem = this.processDataItem(dataItem, groups, config);\n\n      if (!processDataItem) continue;\n\n      if (processDataItem.success) this.collectionSize++;\n      // ensure indexes modified by this data item are waiting to be ingested for regen\n      processDataItem.affectedIndexes.forEach(index =>\n        indexesToRegenOnceComplete.add(index)\n      );\n    }\n\n    indexesToRegenOnceComplete.forEach(index => {\n      this.global.ingest({\n        type: JobType.INDEX_UPDATE,\n        collection: this.name,\n        property: index,\n        value: this.indexes.privateGet(index),\n        previousValue: previousIndexValues[index],\n        dep: this.global.getDep(index, this.indexes.object)\n      });\n    });\n\n    this.global.collecting = false;\n  }\n\n  processDataItem(dataItem: object, groups: Array<string> = [], config) {\n    if (!this.primaryKey) this.findPrimaryKey(dataItem);\n\n    if (!this.primaryKey) return false;\n\n    const key = dataItem[this.primaryKey as number | string];\n\n    // find affected indexes\n    let affectedIndexes = [...groups];\n\n    // searchIndexesForPrimaryKey returns an array of indexes that include that primaryKey\n    // for each index found, if it is not already known, add to affected indexes\n    this.searchIndexesForPrimaryKey(key).map(\n      index => !affectedIndexes.includes(index) && affectedIndexes.push(index)\n    );\n\n    // validate against model\n\n    // create the dep class\n    if (!this.internalDataDeps[key])\n      this.internalDataDeps[key] = new Dep(this.global, 'internal', this, key);\n\n    // ingest the data\n    this.global.ingest({\n      type: JobType.INTERNAL_DATA_MUTATION,\n      collection: this.name,\n      property: key,\n      value: dataItem,\n      dep: this.internalDataDeps[key]\n    });\n\n    // add the data to group indexes\n    for (let i = 0; i < groups.length; i++) {\n      const groupName = groups[i];\n      let index = this.indexes.privateGet(groupName);\n\n      // remove key if already present in index\n      index = index.filter(k => k != key);\n\n      if (config.append) index.push(key);\n      else index.unshift(key);\n\n      // write index\n      this.indexes.privateWrite(groupName, index);\n    }\n    return { success: true, affectedIndexes };\n  }\n\n  private searchIndexesForPrimaryKey(\n    primaryKey: string | number\n  ): Array<string> {\n    // get a fresh copy of the keys to include dynamic indexes\n    const keys = this.indexes.getKeys();\n\n    let foundIndexes: Array<string> = [];\n\n    // for every index\n    for (let i = 0; i < keys.length; i++) {\n      const indexName = keys[i];\n\n      // if the index includes the primaryKey\n      if (this.indexes.privateGet(indexName).includes(primaryKey))\n        foundIndexes.push(indexName);\n    }\n    return foundIndexes;\n  }\n\n  getPreviousIndexValues(groups) {\n    const returnData = {};\n    for (let i = 0; i < groups; i++) {\n      const groupName = groups[i];\n      returnData[groupName] = this.indexes.privateGet(groupName);\n    }\n    return returnData;\n  }\n\n  findPrimaryKey(dataItem) {\n    if (dataItem.hasOwnProperty('id')) this.primaryKey = 'id';\n    else if (dataItem.hasOwnProperty('_id')) this.primaryKey = '_id';\n    else if (dataItem.hasOwnProperty('key')) this.primaryKey = 'key';\n    if (this.primaryKey) return true;\n    else return assert(warn => warn.NO_PRIMARY_KEY);\n  }\n\n  replaceIndex(indexName: string, newIndex: Array<string | number>) {\n    if (!Array.isArray(newIndex) || typeof indexName !== 'string')\n      return assert(warn => warn.INVALID_PARAMETER, 'replaceIndex');\n    this.global.ingest({\n      type: JobType.INDEX_UPDATE,\n      collection: this.name,\n      property: indexName,\n      value: newIndex\n    });\n  }\n\n  // if a computed function evaluates and creates a relation to internal data\n  // that does not exist yet, we create the dep class and save it in advance\n  // so that if the data ever arrives, it will reactively dependent update accordingly\n  depForInternalData(primaryKey: string | number): Dep {\n    let dep: Dep;\n    // debugger;\n    if (!this.internalDataDeps[primaryKey]) {\n      dep = new Dep(this.global, 'internal', this, primaryKey);\n      this.internalDataDeps[primaryKey] = dep;\n    } else {\n      dep = this.internalDataDeps[primaryKey];\n    }\n    return dep;\n  }\n\n  //\n  depForGroup(groupName: string): Dep {\n    let dep: Dep;\n    // no group is found publically, use index instead\n    if (this.public.exists(groupName)) {\n      dep = this.global.getDep(groupName, this.name);\n    } else if (this.indexes.exists(groupName)) {\n      dep = this.global.getDep(groupName, this.indexes.object);\n    } else {\n      dep = this.indexes.tempDep(groupName);\n    }\n    return dep;\n  }\n\n  findById(id: string | number) {\n    let internalDep: Dep = this.depForInternalData(id);\n\n    if (this.global.runningComputed) {\n      let computed = this.global.runningComputed as Computed;\n      this.global.relations.relate(computed, internalDep);\n    }\n    if (this.global.runningPopulate) {\n      let populate = this.global.runningPopulate as Dep;\n      this.global.relations.relate(populate, internalDep);\n    }\n    return this.internalData[id];\n  }\n\n  getGroup(property) {\n    let groupDep: Dep = this.depForGroup(property);\n    // if called inside Computed method, create temporary relation in relationship controller\n    if (this.global.runningComputed) {\n      let computed = this.global.runningComputed as Computed;\n      this.global.relations.relate(computed, groupDep);\n    }\n    // if called from within populate() create another temporary relation\n    if (this.global.runningPopulate) {\n      let dataDep = this.global.runningPopulate as Dep;\n      this.global.relations.relate(dataDep, groupDep);\n    }\n    // get group is not cached, so generate a fresh group from the index\n    return this.buildGroupFromIndex(property) || [];\n  }\n\n  // action functions\n  undo() {}\n  throttle() {}\n\n  // group functions\n  move(\n    ids: number | Array<string | number>,\n    sourceIndexName: string,\n    destIndexName?: string,\n    method: 'push' | 'unshift' = 'push'\n  ) {\n    // validation\n    if (!this.indexes.exists(sourceIndexName))\n      return assert(warn => warn.INDEX_NOT_FOUND, 'move');\n\n    if (destIndexName && !this.indexes.exists(destIndexName))\n      return assert(warn => warn.INDEX_NOT_FOUND, 'move');\n\n    if (!Array.isArray(ids)) ids = [ids];\n\n    let sourceIndex = this.indexes.privateGet(sourceIndexName);\n    for (let i = 0; i < ids.length; i++)\n      sourceIndex = sourceIndex.filter(id => id !== ids[i]);\n\n    this.global.ingest({\n      type: JobType.INDEX_UPDATE,\n      collection: this.name,\n      property: sourceIndexName,\n      value: sourceIndex\n    });\n\n    if (destIndexName) {\n      let destIndex = this.indexes.privateGet(destIndexName);\n\n      for (let i = 0; i < ids.length; i++) {\n        // destIndex = destIndex.filter(k => k != ids[i]);\n\n        if (destIndex.includes(ids[i])) continue;\n\n        // push or unshift id into current index\n        destIndex[method](ids[i]);\n      }\n\n      this.global.ingest({\n        type: JobType.INDEX_UPDATE,\n        collection: this.name,\n        property: destIndexName,\n        value: destIndex\n      });\n    }\n  }\n\n  put(\n    ids: number | Array<string | number>,\n    destIndexName: string,\n    method: 'push' | 'unshift' = 'push'\n  ) {\n    // validation\n    if (!this.indexes.exists(destIndexName))\n      return assert(warn => warn.INDEX_NOT_FOUND, 'put');\n\n    if (!Array.isArray(ids)) ids = [ids];\n\n    // get current index\n    let destIndex = this.indexes.privateGet(destIndexName);\n\n    // This doesn't work because the array spead sets the object to index: value rather than just the values\n    // let test = { ...destIndex };\n    // ids.map(k => {\n    //   if (test[k]) return;\n    //   test[k] = true;\n    // });\n    // destIndex = Object.keys(test).map(k => Number(k));\n\n    // loop over every id user is trying to add into current index\n    for (let i = 0; i < ids.length; i++) {\n      // destIndex = destIndex.filter(k => k != ids[i]);\n\n      if (destIndex.includes(ids[i])) continue;\n\n      // push or unshift id into current index\n      destIndex[method](ids[i]);\n    }\n\n    this.global.ingest({\n      type: JobType.INDEX_UPDATE,\n      collection: this.name,\n      property: destIndexName,\n      value: destIndex\n    });\n  }\n\n  newGroup(groupName: string, indexValue?: Array<string | number>) {\n    if (this.indexes.object.hasOwnProperty(groupName))\n      return assert(warn => warn.GROUP_ALREADY_EXISTS, 'newGroup');\n\n    this.global.ingest({\n      type: JobType.INDEX_UPDATE,\n      collection: this.name,\n      property: groupName,\n      value: indexValue\n    });\n  }\n  deleteGroup(groupName: string) {\n    this.global.ingest({\n      type: JobType.INDEX_UPDATE,\n      collection: this.name,\n      property: groupName,\n      value: []\n    });\n  }\n  removeFromGroup(\n    groupName: string,\n    itemsToRemove: number | string | Array<number | string>\n  ) {\n    if (!this.indexes.exists(groupName))\n      return assert(warn => warn.INDEX_NOT_FOUND, 'removeFromGroup');\n\n    if (!Array.isArray(itemsToRemove)) itemsToRemove = [itemsToRemove];\n\n    const index = this.indexes.privateGet(groupName);\n\n    const newIndex = index.filter(\n      id => !(itemsToRemove as Array<number | string>).includes(id)\n    );\n\n    this.global.ingest({\n      type: JobType.INDEX_UPDATE,\n      collection: this.name,\n      property: groupName,\n      value: newIndex\n    });\n  }\n\n  // internal data functions\n  update(primaryKey: string | number, newObject: { [key: string]: any }) {\n    if (!this.internalData.hasOwnProperty(primaryKey))\n      return assert(warn => warn.INTERNAL_DATA_NOT_FOUND, 'update');\n\n    const newObjectKeys = Object.keys(newObject);\n    const currentData = Object.assign({}, this.internalData[primaryKey]);\n\n    for (let i = 0; i < newObjectKeys.length; i++) {\n      const key = newObjectKeys[i];\n      currentData[key] = newObject[key];\n    }\n    this.global.ingest({\n      type: JobType.INTERNAL_DATA_MUTATION,\n      collection: this.name,\n      property: primaryKey,\n      value: currentData\n    });\n  }\n  increment(\n    primaryKey: string | number,\n    property: string,\n    amount: number,\n    decrement?: boolean\n  ) {\n    if (!this.internalData.hasOwnProperty(primaryKey))\n      return assert(\n        warn => warn.INTERNAL_DATA_NOT_FOUND,\n        decrement ? 'decrement' : 'increment'\n      );\n\n    const currentData = Object.assign({}, this.internalData[primaryKey]);\n\n    if (!validateNumber(amount, currentData[property]))\n      return assert(\n        warn => warn.PROPERTY_NOT_A_NUMBER,\n        decrement ? 'decrement' : 'increment'\n      );\n\n    if (decrement) currentData[property] -= amount;\n    else currentData[property] += amount;\n\n    this.global.ingest({\n      type: JobType.INTERNAL_DATA_MUTATION,\n      collection: this.name,\n      property: primaryKey,\n      value: currentData\n    });\n  }\n  decrement(primaryKey: string | number, property: string, amount: number) {\n    this.increment(primaryKey, property, amount, true);\n  }\n\n  delete(primaryKeys: string | number | Array<string | number>) {\n    if (!Array.isArray(primaryKeys)) primaryKeys = [primaryKeys];\n    for (let i = 0; i < primaryKeys.length; i++) {\n      const primaryKey = primaryKeys[i];\n      this.global.ingest({\n        type: JobType.DELETE_INTERNAL_DATA,\n        collection: this.name,\n        property: primaryKey\n      });\n    }\n  }\n\n  // remove all dynamic indexes, empty all indexes, delete all internal data\n  purge() {}\n\n  // external functions\n  watch(property, callback) {\n    if (!this.externalWatchers[property])\n      this.externalWatchers[property] = [callback];\n    else this.externalWatchers[property].push(callback);\n  }\n\n  forceUpdate(property: string): void {\n    // ensure property exists on collection\n    if (this.public.exists(property)) {\n      // if property is directly mutable\n\n      if (this.public.mutable.includes(property)) {\n        this.global.ingest({\n          type: JobType.PUBLIC_DATA_MUTATION,\n          property,\n          collection: this.name,\n          value: this.public.privateGet(property),\n          dep: this.global.getDep(property, this.name)\n        });\n\n        // if property is a computed method\n      } else if (this.computed[property]) {\n        this.global.ingest({\n          type: JobType.COMPUTED_REGEN,\n          property,\n          collection: this.name,\n          dep: this.global.getDep(property, this.name)\n        });\n      }\n    }\n  }\n\n  // deprecate\n  // added removeFromGroup to be more specific, params got switched around, keeping this for backwards compatibility\n  remove(itemsToRemove, groupName) {\n    return this.removeFromGroup(groupName, itemsToRemove);\n  }\n}\n","// This file handles external components subscribing to pulse.\n// It also handles subscribing mapData properties to collections\n\nimport { uuid, cleanse, isWatchableObject } from './helpers';\nimport { ComponentContainer } from './interfaces';\nimport Dep from './dep';\nimport { worker } from 'cluster';\n\ninterface SubscribingComponentObject {\n  componentUUID: string;\n  keys: Array<string>;\n}\n\nexport default class SubController {\n  public subscribingComponentKey: number = 0;\n  public subscribingComponent: boolean | SubscribingComponentObject = false;\n  public unsubscribingComponent: boolean = false;\n  public skimmingDeepReactive: boolean = false;\n  public uuid: any = uuid;\n  public lastAccessedDep: null | Dep = null;\n\n  public componentStore: { [key: string]: ComponentContainer } = {};\n\n  constructor(private getContext) {}\n\n  registerComponent(instance, config) {\n    let uuid = instance.__pulseUniqueIdentifier;\n    if (!uuid) {\n      // generate UUID\n      uuid = this.uuid();\n      // inject uuid into component instance\n      const componentContainer = {\n        instance: instance,\n        uuid,\n        ready: config.waitForMount ? false : true\n      };\n      instance.__pulseUniqueIdentifier = uuid;\n\n      this.componentStore[uuid] = componentContainer;\n    } else {\n      this.mount(instance);\n    }\n    return uuid;\n  }\n\n  mount(instance) {\n    let component = this.componentStore[instance.__pulseUniqueIdentifier];\n\n    if (component) {\n      component.instance = instance;\n      component.ready = true;\n    }\n  }\n\n  unmount(instance) {\n    const uuid = instance.__pulseUniqueIdentifier;\n    if (!uuid) return;\n\n    // delete refrence to this component from store\n    delete this.componentStore[instance.__pulseUniqueIdentifier];\n  }\n\n  subscribePropertiesToComponents(properties, componentUUID) {\n    // provisionally get keys of mapped data\n    const provision = properties(this.getContext());\n\n    const keys = Object.keys(provision);\n\n    // mapData has a user defined local key, we need to include that in the\n    // subscription so we know what to update on the component later.\n    this.subscribingComponentKey = 0;\n\n    this.subscribingComponent = {\n      componentUUID,\n      keys\n    };\n\n    let returnToComponent = properties(this.getContext());\n\n    this.subscribingComponent = false;\n\n    this.subscribingComponentKey = 0;\n\n    // cleanse any deep objects of their getters/setters from Pulse and ensure object is a copy\n    // Object.keys(returnToComponent).forEach(property => {\n    //   returnToComponent[property] = cleanse(returnToComponent[property]);\n    // });\n    // returnToComponent = Object.assign({}, returnToComponent);\n\n    // console.log(returnToComponent);\n\n    return returnToComponent;\n  }\n\n  prepareNext(dep) {\n    this.lastAccessedDep = dep;\n    if (!this.skimmingDeepReactive) this.subscribingComponentKey++;\n  }\n\n  foundDeepReactive() {\n    this.skimmingDeepReactive = true;\n    // undo changes\n    this.lastAccessedDep.subscribers.pop();\n    this.subscribingComponentKey--;\n  }\n\n  exitDeepReactive() {\n    this.skimmingDeepReactive = false;\n    //redo changes\n    this.lastAccessedDep.subscribe();\n    this.subscribingComponentKey++;\n  }\n}\n","interface StorageMethods {\n  async?: boolean;\n  get?: any;\n  set?: any;\n  remove?: any;\n}\n\nexport default class Storage {\n  private isPromise: boolean = false;\n  private storageReady: boolean = false;\n  private storageType: 'localStorage' | 'custom' = 'localStorage';\n  constructor(private storageMethods: StorageMethods = {}) {\n    if (storageMethods.async) this.isPromise = true;\n\n    // assume if user provided get, set or remove methods that the storage type is custom\n    if (storageMethods.get || storageMethods.set || storageMethods.remove) {\n      this.storageType = 'custom';\n    }\n\n    if (this.localStorageAvaliable() && this.storageType === 'localStorage') {\n      this.storageReady = true;\n      storageMethods.get = localStorage.getItem.bind(localStorage);\n      storageMethods.set = localStorage.setItem.bind(localStorage);\n      storageMethods.remove = localStorage.removeItem.bind(localStorage);\n    } else {\n      this.storageType = 'custom';\n\n      if (\n        this.check(storageMethods.get) &&\n        this.check(storageMethods.set) &&\n        this.check(storageMethods.remove)\n      ) {\n        this.storageReady = true;\n      } else {\n        this.storageReady = false;\n        // bad\n      }\n    }\n  }\n\n  public get(collection, key) {\n    if (!this.storageReady) return;\n\n    if (this.isPromise) {\n      return new Promise((resolve, reject) => {\n        this.storageMethods\n          .get(this.getKey(collection, key))\n          .then(res => {\n            // if result is not JSON for some reason, return it.\n            if (typeof res !== 'string') return resolve(res);\n\n            resolve(JSON.parse(res));\n          })\n          .catch(reject);\n      });\n    } else {\n      return JSON.parse(this.storageMethods.get(this.getKey(collection, key)));\n    }\n  }\n\n  public set(collection, key, value) {\n    if (!this.storageReady) return;\n    this.storageMethods.set(\n      this.getKey(collection, key),\n      JSON.stringify(value)\n    );\n  }\n\n  public remove(collection, key) {\n    if (!this.storageReady) return;\n    this.storageMethods.remove(this.getKey(collection, key));\n  }\n\n  private getKey(collection, key) {\n    return `_${collection}_${key}`;\n  }\n\n  private check(func) {\n    return typeof func === 'function';\n  }\n\n  private localStorageAvaliable() {\n    try {\n      localStorage.setItem('_', '_');\n      localStorage.removeItem('_');\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n}\n","import Collection from '../collection';\nimport { Global, ExpandableObject, RequestConfig } from '../interfaces';\n\ntype Method = 'get' | 'put' | 'post' | 'patch' | 'delete';\n\nexport default class Request extends Collection {\n  private timeout: number;\n  private options: ExpandableObject;\n  private saveHistory: boolean;\n\n  private requestIntercept: (\n    context: ExpandableObject,\n    options: ExpandableObject\n  ) => void;\n  private responseIntercept: (\n    context: ExpandableObject,\n    response: ExpandableObject\n  ) => void;\n\n  constructor(global: Global, requestConfig: RequestConfig) {\n    // Before we invoke the parent class, we define some defaults\n    let groups = [];\n    let persist = ['baseURL'];\n    let data = {\n      baseURL: requestConfig.baseURL || '',\n      mode: 'cors',\n      credentials: 'same-origin',\n      headers: {\n        Accept: 'application/json'\n      }\n    };\n\n    if (requestConfig.headers)\n      Object.keys(requestConfig.headers).forEach(header => {\n        data.headers[header] = requestConfig.headers[header];\n      });\n\n    if (requestConfig.credentials) data.credentials = requestConfig.credentials;\n    if (requestConfig.mode) data.mode = requestConfig.mode;\n\n    super('request', global, { groups, data, persist });\n\n    this.requestIntercept = requestConfig.requestIntercept;\n    this.responseIntercept = requestConfig.responseIntercept;\n    this.timeout = requestConfig.timeout;\n    this.saveHistory =\n      typeof requestConfig.saveHistory === 'undefined' ? true : false;\n\n    this.global.request = {\n      get: this.get.bind(this),\n      post: this.post.bind(this),\n      put: this._put.bind(this),\n      patch: this.patch.bind(this),\n      delete: this.delete.bind(this),\n      queryify: this.queryify.bind(this)\n    };\n  }\n\n  get(url: string, headers?: ExpandableObject) {\n    return this.send(url, 'get', {}, headers);\n  }\n\n  post(url: string, body?: ExpandableObject, headers?: ExpandableObject) {\n    return this.send(url, 'post', body, headers);\n  }\n\n  _put(url: string, body?: ExpandableObject, headers?: ExpandableObject) {\n    return this.send(url, 'put', body, headers);\n  }\n\n  patch(url: string, body?: ExpandableObject, headers?: ExpandableObject) {\n    return this.send(url, 'patch', body, headers);\n  }\n\n  delete(url: string, body?: ExpandableObject, headers?: ExpandableObject) {\n    return this.send(url, 'delete', body, headers);\n  }\n\n  async send(\n    url: string,\n    method: Method,\n    body: ExpandableObject | string = {},\n    headers: ExpandableObject\n  ) {\n    const requestHeaders = Object.assign({}, this.public.object.headers);\n\n    if (headers)\n      Object.keys(headers).forEach(header => {\n        requestHeaders[header] = headers[header];\n      });\n\n    // If method is not get set application type\n    if (method !== 'get' && requestHeaders['Content-Type'] === undefined)\n      requestHeaders['Content-Type'] = 'application/json';\n\n    let fullURL;\n\n    if (url.startsWith('http')) fullURL = url;\n    else fullURL = `${this.public.object.baseURL}/${url}`;\n\n    // Stringify body\n    body = JSON.stringify(body);\n\n    // Build options\n    this.options = {};\n    this.options.credentials = this.public.object.credentials;\n    this.options.mode = this.public.object.mode;\n\n    // Build final fetch options object\n    const options = Object.assign(\n      {\n        headers: requestHeaders,\n        method: method.toUpperCase(),\n        body: method === 'get' ? null : body\n      },\n      this.options\n    );\n\n    if (this.requestIntercept)\n      this.requestIntercept(this.global.getContext('request'), options);\n\n    let response: any;\n\n    if (this.timeout) {\n      response = await Promise.race([\n        fetch(fullURL, options),\n        new Promise((resolve, reject) =>\n          setTimeout(() => reject('timeout'), this.timeout)\n        )\n      ]);\n    } else {\n      response = await fetch(fullURL, options);\n    }\n\n    const contentType = response.headers.get('content-type');\n\n    // extract body\n    if (contentType && contentType.indexOf('application/json') !== -1) {\n      body = await response.json();\n    } else {\n      body = await response.text();\n    }\n\n    // history\n    if (!this.saveHistory)\n      this.collect({\n        id: Date.now(),\n        status: response.status,\n        timestamp: new Date(),\n        response: body\n      });\n\n    // inject headers into prototype\n    let final;\n\n    // If reponse body is an object, create a custom object with response function in prototype, so headers and the full response data can be accessed outside of this class\n    if (!Array.isArray(body) && typeof body === 'object') {\n      final = Object.create({\n        response: () => {\n          return response;\n        }\n      });\n      const keys = Object.keys(body);\n      for (let i = 0; i < keys.length; i++) {\n        const property = keys[i];\n        final[property] = body[property];\n      }\n      // if the body is not an object, we can not inject a prototype, so just return the rew body\n    } else {\n      final = body;\n    }\n    // intercept response\n    if (this.responseIntercept) {\n      response.data = body;\n      this.responseIntercept(this.global.getContext('request'), response);\n    }\n\n    // reject if bad response status\n    if (response.ok || response.redirected) return final;\n\n    // resolve response\n    throw final;\n  }\n\n  // Adapted from: https://github.com/Gozala/querystring/blob/master/encode.js\n  queryify(obj) {\n    const stringifyPrimitive = function(value) {\n      switch (typeof value) {\n        case 'string':\n          return value;\n\n        case 'boolean':\n          return value ? 'true' : 'false';\n\n        case 'number':\n          return isFinite(value) ? value : '';\n\n        default:\n          return '';\n      }\n    };\n    // validate input\n    if (typeof obj != 'object') return;\n\n    return Object.keys(obj)\n      .map(key => {\n        const encodedKey = encodeURIComponent(stringifyPrimitive(key)) + '=';\n        // if value is an array, encode with same key as parent\n        if (Array.isArray(obj[key]))\n          return obj[key]\n            .map(value => {\n              return encodedKey + encodeURIComponent(stringifyPrimitive(value));\n            })\n            .join('&');\n        // join encoded key with value\n        return encodedKey + encodeURIComponent(stringifyPrimitive(obj[key]));\n      })\n      .join('&');\n  }\n}\n","import Collection from '../collection';\nimport { Global, RootCollectionObject } from '../interfaces';\n\nexport default class Request extends Collection {\n  constructor(global: Global, root: RootCollectionObject = {}) {\n    root = Object.assign({}, root);\n\n    // Base as a collection is configured directly from the root of the Pulse config,\n    // thus to be verbose we remove the properties only used for global setup\n    // default collection properties like data, computed, actions etc will remain\n    delete root.collections;\n    delete root.request;\n\n    // if user has not created data or persist properties, create them for the defaults.\n    if (!root.data) root.data = {};\n    if (!root.persist) root.persist = [];\n\n    // can be used to preserve authenticated state\n    // automatically persists if local storage is availible\n    root.data['isAuthenticated'] = false;\n    root.persist.push('isAuthenticated');\n\n    // can be used to declare once the app has finished initilazation, does not affect Pulse\n    root.data['appReady'] = false;\n\n    super('base', global, root);\n  }\n}\n","function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","import Runtime from './runtime';\nimport Collection from './collection';\nimport SubController from './subController';\nimport Storage from './storage';\nimport Request from './collections/request';\nimport Base from './collections/base';\nimport withPulse from './wrappers/ReactWithPulse';\nimport {\n  uuid,\n  normalizeMap,\n  log,\n  defineConfig,\n  parse,\n  cleanse\n} from './helpers';\nimport { Private, RootCollectionObject, DebugType } from './interfaces';\nimport { JobType } from './runtime';\n\nimport RelationController, { Key } from './relationController';\nimport Dep from './dep';\n\nexport default class Library {\n  _private: Private;\n  [key: string]: any;\n  constructor(root: RootCollectionObject = {}) {\n    // Private object contains all internal Pulse data\n    this._private = {\n      runtime: null,\n      events: {},\n      collections: {},\n      collectionKeys: [],\n      // global is passed in to all classes, must not contain cyclic references\n      global: {\n        config: this.prepareConfig(root.config),\n        // State\n        initComplete: false,\n        runningAction: false,\n        runningWatcher: false,\n        runningComputed: false,\n        runningPopulate: false,\n        mappingData: false,\n        collecting: false,\n        touching: false,\n        touched: false,\n        contextRef: {},\n        // Instances\n        subs: new SubController(this.getContext.bind(this)),\n        relations: null,\n        storage: null,\n        // Function aliases\n        dispatch: this.dispatch.bind(this),\n        getInternalData: this.getInternalData.bind(this),\n        getContext: this.getContext.bind(this),\n        getDep: this.getDep.bind(this),\n        uuid\n      }\n    };\n\n    // Bind static objects to instance (utils and services eventually should be initialized)\n    ['utils', 'services', 'staticData'].forEach(type => {\n      if (root[type]) this[type] = root[type];\n    });\n\n    // Create storage instance\n    this._private.global.storage = new Storage(root.storage);\n\n    // Create relation controller instance\n    this._private.global.relations = new RelationController(\n      this._private.global\n    );\n\n    // Prepare\n    this.initCollections(root);\n    this.initRuntime();\n\n    // Finalize\n    this.bindCollectionPublicData();\n    this.runAllComputed();\n\n    this.initComplete();\n  }\n\n  initCollections(root: RootCollectionObject) {\n    this._private.collectionKeys = [];\n    if (root.collections) {\n      this._private.collectionKeys = [\n        ...Object.keys(root.collections),\n        ...this._private.collectionKeys\n      ];\n      for (let i = 0; i < this._private.collectionKeys.length; i++) {\n        // Create collection instance\n        this._private.collections[\n          this._private.collectionKeys[i]\n        ] = new Collection(\n          this._private.collectionKeys[i], // name\n          this._private.global, // global\n          root.collections[this._private.collectionKeys[i]] // collection config\n        );\n      }\n    }\n    // Create request class\n    if (this._private.global.config.enableRequest !== false)\n      this._private.collectionKeys.push('request');\n    this._private.collections['request'] = new Request(\n      this._private.global,\n      root.request || {}\n    );\n\n    // Create base class\n    if (this._private.global.config.enableBase !== false) {\n      this._private.collectionKeys.push('base');\n      this._private.collections['base'] = new Base(this._private.global, root);\n    }\n  }\n\n  initRuntime() {\n    this._private.runtime = new Runtime(\n      this._private.collections,\n      this._private.global\n    );\n  }\n\n  private bindCollectionPublicData(): void {\n    for (let i = 0; i < this._private.collectionKeys.length; i++) {\n      const collection = this._private.collections[\n        this._private.collectionKeys[i]\n      ];\n      this._private.global.contextRef[this._private.collectionKeys[i]] =\n        collection.public.object;\n\n      this[this._private.collectionKeys[i]] = collection.public.object;\n    }\n  }\n\n  runAllComputed() {\n    for (let i = 0; i < this._private.collectionKeys.length; i++) {\n      const collection = this._private.collections[\n        this._private.collectionKeys[i]\n      ];\n\n      const computedKeys = collection.keys.computed;\n      for (let i = 0; i < computedKeys.length; i++) {\n        const computedName = computedKeys[i];\n        this._private.runtime.performComputedOutput({\n          collection: collection.name,\n          property: computedName,\n          type: JobType.COMPUTED_REGEN\n        });\n        collection.runWatchers(computedName);\n      }\n    }\n  }\n\n  initComplete() {\n    this._private.global.initComplete = true;\n    log('INIT COMPLETE', Object.assign({}, this));\n    if (!this._private.global.config.ssr) {\n      try {\n        window._pulse = this;\n      } catch (e) {}\n    }\n  }\n\n  public wrapped(ReactComponent, mapData) {\n    const config = this._private.global.config;\n    if (config.framework === 'react' && config.frameworkConstructor) {\n      return withPulse(\n        this,\n        config.frameworkConstructor,\n        ReactComponent,\n        mapData\n      );\n    } else return false;\n  }\n\n  private prepareConfig(config) {\n    // defaults\n    config = defineConfig(config, {\n      framework: null,\n      waitForMount: false,\n      autoUnmount: false\n    });\n\n    // detect if framework passed in is a React constructor\n    if (\n      config.framework &&\n      config.framework.hasOwnProperty(\n        '__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED'\n      )\n    ) {\n      config.frameworkConstructor = config.framework;\n      config.framework = 'react';\n    }\n\n    if (config.framework === 'react') {\n      if (config.waitForMount != false) config.waitForMount = true;\n      if (config.autoUnmount != false) config.autoUnmount = true;\n    }\n    return config;\n  }\n\n  getInternalData(collection, primaryKey) {\n    return this._private.collections[collection].findById(primaryKey);\n  }\n\n  // returns Dep instance by \"touching\" reactive property revealing its Dep class\n  // if collection param is present we'll assume the property param is the name of the property, not a reference to the property itself\n  getDep(property: any, collection: string, forData?: boolean): Dep {\n    let dep: Dep;\n    // if forData is true we'll go straight for the internal dep\n    if (!forData) {\n      // \"touching\" is simply invoking the property's getter\n      this._private.global.touching = true;\n      if (typeof collection === 'string') {\n        this._private.collections[collection].public.object[property];\n      } else if (typeof collection === 'object') {\n        collection[property];\n      }\n\n      // Extract the dep\n      dep = this._private.global.touched as Dep;\n      this._private.global.touching = false;\n      this._private.global.touched = null;\n\n      // if still no dep found, look inward lol\n      if (!dep)\n        dep = this._private.collections[collection].internalDataDeps[property];\n    } else {\n      dep = this._private.collections[collection].internalDataDeps[property];\n    }\n    return dep as Dep;\n  }\n\n  dispatch(type: string, payload) {\n    switch (type) {\n      case 'mutation':\n        this._private.runtime.ingest({\n          type: JobType.PUBLIC_DATA_MUTATION,\n          collection: payload.collection,\n          property: payload.key,\n          value: payload.value,\n          dep: payload.dep\n        });\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  getContext(collection) {\n    const c = this._private.collections[collection];\n    if (!c) return this._private.global.contextRef;\n    return {\n      ...this._private.global.contextRef,\n      ...c.methods,\n      data: c.public.object,\n      indexes: c.indexes.object,\n      groups: c.public.object,\n      computed: c.public.object,\n      routes: c.public.object.routes,\n      local: c.local\n    };\n  }\n\n  install(Vue) {\n    this._private.global.config.framework = 'vue';\n    const pulse = this;\n    const config = pulse._private.global.config;\n    Vue.mixin({\n      beforeCreate() {\n        Object.keys(pulse._private.global.contextRef).forEach(collection => {\n          this['$' + collection] = pulse._private.global.contextRef[collection];\n        });\n\n        if (pulse.utils) this.$utils = pulse.utils;\n        if (pulse.services) this.$services = pulse.services;\n        if (pulse.staticData) this.$staticData = pulse.staticData;\n\n        this.mapData = properties =>\n          pulse.mapData(\n            properties,\n            this,\n            {\n              waitForMount: config.waitForMount\n            },\n            pulse\n          );\n      },\n      mounted() {\n        if (this.__pulseUniqueIdentifier && config.waitForMount)\n          pulse.mount(this);\n      },\n      beforeDestroy() {\n        if (this.__pulseUniqueIdentifier && config.autoUnmount)\n          pulse.unmount(this);\n      }\n    });\n  }\n\n  mount(instance) {\n    this._private.global.subs.mount(instance);\n  }\n\n  unmount(instance) {\n    this._private.global.subs.unmount(instance);\n  }\n\n  mapData(properties, instance = {}, _config = {}, pulseAlias?: any) {\n    let pulse = pulseAlias ? pulseAlias : this;\n    const config = {\n      waitForMount: true,\n      ..._config\n    };\n    const componentUUID = pulse._private.global.subs.registerComponent(\n      instance,\n      config\n    );\n\n    this._private.global.mappingData = true;\n    // new cool mapData method\n    if (typeof properties === 'function') {\n      return pulse._private.global.subs.subscribePropertiesToComponents(\n        properties,\n        componentUUID\n      );\n      // legacy support....\n    } else if (typeof properties === 'object') {\n      let returnData = {};\n      normalizeMap(properties).forEach(({ key, val }) => {\n        let collection = val.split('/')[0];\n        let property = val.split('/')[1];\n        let c = pulse._private.global.getContext()[collection];\n        returnData[\n          key\n        ] = pulse._private.global.subs.subscribePropertiesToComponents(() => {\n          return { [key]: c[property] };\n        }, componentUUID)[key];\n      });\n      this._private.global.mappingData = false;\n\n      returnData = cleanse(returnData);\n\n      return returnData;\n    }\n  }\n\n  emit(name: string, payload: any): void {\n    if (this._private.events[name])\n      for (let i = 0; i < this._private.events[name].length; i++) {\n        const callback = this._private.events[name][i];\n        callback(payload);\n      }\n  }\n  on(name: string, callback: () => any): void {\n    if (!Array.isArray(this._private.events[name]))\n      this._private.events[name] = [callback];\n    else this._private.events[name].push(callback);\n  }\n\n  log(type: DebugType): void {\n    // let debugMode: Set<DebugType> = this._private.global.config.debugMode;\n    // if (debugMode.size === 0) return;\n    // if (debugMode.has(DebugType.ERRORS)) {\n    // }\n    // log(DebugType.ASSERT, `There was an error with \"${thing}\", bad :(`);\n    // const AssertMessages = {\n    //   INDEX_UPDATE_FAILED: (collection, property) =>\n    //     `The type ${collection} is ${property}.`\n    //   // and more\n    // };\n    // function _log(callback) {\n    // }\n    // _log(({ AssertMessages }) => AssertMessages.INDEX_UPDATE_FAILED(thing, thing2));\n  }\n}\n"],"names":["defineConfig","config","defaults","uuid","Math","random","toString","split","Date","now","objectLoop","object","callback","keys","objectKeys","Object","i","length","key_1","isWatchableObject","value","type","obj","HTMLElement","e","nodeType","style","ownerDocument","Array","isArray","log","payload","normalizeMap","map","key","val","cleanse","clean","assign","properties","property","assert","func","funcName","NO_PRIMARY_KEY","INVALID_PARAMETER","INDEX_NOT_FOUND","INTERNAL_DATA_NOT_FOUND","PROPERTY_NOT_A_NUMBER","validateNumber","mutable","amount","_defineProperty","defineProperty","enumerable","configurable","writable","_objectSpread","target","arguments","source","ownKeys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","forEach","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","prototype","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","call","_typeof","assertThisInitialized","_inherits","subClass","superClass","create","constructor","setPrototypeOf","_extends","hasOwnProperty","apply","this","withPulse","pulse","React","ReactComponent","selectData","state","mapData","waitForMount","_private","global","mount","autoUnmount","unmount","createElement","Component","protectedNames","collectionFunctions","arrayFunctions","colleciton","propertyName","rootProperty","Set","Dep","subs","runningComputed","dependents","add","runningPopulate","relations","relate","subscribingComponent","subscribeComponent","unsubscribingComponent","cleanup","dynamicRelation","skimmingDeepReactive","prepareNext","foundDeepReactive","exitDeepReactive","subscribe","subscribingComponentKey","component","componentUUID","subscribers","push","collection","name","computedFunction","Computed","output","getContext","undefined","updateThis","DynamicRelation","depsToClean","dep","delete","_this","RelationController","whenDepChanges","relationBank","destroy","RelationTypes","JobType","collections","ingest","bind","ingestDependents","Runtime","job","ingestQueue","running","findNextJob","next","shift","INDEX_UPDATE","getDep","performJob","PUBLIC_DATA_MUTATION","performPublicDataUpdate","runWatchers","INTERNAL_DATA_MUTATION","performInternalDataUpdate","performIndexUpdate","COMPUTED_REGEN","performComputedOutput","GROUP_UPDATE","SOFT_GROUP_UPDATE","performGroupRebuild","DELETE_INTERNAL_DATA","performInternalDataDeletion","size","finished","ingestComputed","computed","dependent","completedJobs","setTimeout","updatingSubscribers","compileComponentUpdates","writeToPublicObject","completedJob","internalData","previousValue","overwriteInternalData","collecting","searchIndexesForPrimaryKey","index","modifiedGroup","softUpdateGroupData","c","indexesToUpdate","indexName","newIndex","indexes","id","privateWrite","buildGroupFromIndex","run","fromAction","runningAction","initComplete","persistData","changed","componentsToUpdate","i_1","updateSubscribers","componentKeys","componentID","componentInstance","this_1","componentStore","propertiesToUpdate","dataKeys","framework","$set","setState","persist","includes","storage","set","public","primaryKey","newData","currentData","dispatch","reactiveObject","Reactive","deepReactiveObject","createDep","get","sneaky","touching","touched","register","newValue","allowPrivateWrite","tempDeps","getPrototypeOf","cloneDep","objectWithCustomPrototype","array","reactiveArray","slice","original","result","data","bool","action","actionName","prepare","contextRef","undo","Action","exec","context","error","_this_1","executing","root","filters","prepareNamespace","initReactive","groups","initRoutes","routes","initActions","actions","initWatchers","watch","initComputed","initModel","model","initPersist","Collection","methods","local","namespace","normalizeGroups","groupsAsArray","watcher","watchers","externalWatchers","dataName","isPromise","then","actionKeys","watcherKeys","this_2","runningWatcher","watcherOutput","_keys","computedName","routeWrapped","routeName","requestObject","request","internalDataWithPopulate","groupName","constructedArray","privateGet","getData","injectDynamicRelatedData","position","indexOf","currentGroup","populated","populate","group","exists","addProperty","append","createGroups","previousIndexValues","getPreviousIndexValues","indexesToRegenOnceComplete","dataItem","processDataItem","success","collectionSize","affectedIndexes","findPrimaryKey","internalDataDeps","k","unshift","getKeys","foundIndexes","returnData","warn","tempDep","internalDep","depForInternalData","groupDep","depForGroup","dataDep","ids","sourceIndexName","destIndexName","method","sourceIndex","destIndex","indexValue","GROUP_ALREADY_EXISTS","itemsToRemove","newObject","newObjectKeys","decrement","increment","primaryKeys","removeFromGroup","SubController","__pulseUniqueIdentifier","componentContainer","ready","provision","returnToComponent","lastAccessedDep","pop","storageMethods","async","remove","storageType","localStorageAvaliable","storageReady","localStorage","getItem","setItem","removeItem","check","Storage","Promise","resolve","reject","getKey","res","JSON","parse","catch","stringify","requestConfig","baseURL","mode","credentials","headers","Accept","header","_super","requestIntercept","responseIntercept","timeout","saveHistory","post","put","_put","patch","queryify","tslib_1.__extends","Request","url","send","body","requestHeaders","fullURL","startsWith","options","toUpperCase","race","fetch","response","_a","contentType","json","text","collect","status","timestamp","final","ok","redirected","stringifyPrimitive","isFinite","encodedKey","encodeURIComponent","join","_typeof2","Symbol","iterator","module","_getPrototypeOf","o","__proto__","_setPrototypeOf","p","runtime","events","collectionKeys","prepareConfig","mappingData","getInternalData","initCollections","initRuntime","bindCollectionPublicData","runAllComputed","Library","enableRequest","enableBase","Base","computedKeys","ssr","window","_pulse","frameworkConstructor","findById","forData","Vue","mixin","beforeCreate","utils","$utils","services","$services","staticData","$staticData","mounted","beforeDestroy","_config","pulseAlias","registerComponent","subscribePropertiesToComponents","returnData_1"],"mappings":"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"}